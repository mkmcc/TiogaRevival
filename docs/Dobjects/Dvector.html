<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Dobjects::Dvector - RDoc Documentation</title>

<link href="../fonts.css" rel="stylesheet">
<link href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/navigation.js"></script>
<script src="../js/search_index.js"></script>
<script src="../js/search.js"></script>
<script src="../js/searcher.js"></script>
<script src="../js/darkfish.js"></script>


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="Dvector.html#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">Object
  
</div>

    <div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
  
  
    <li><span class="include">Enumerable</span>
  
  
  </ul>
</div>

    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="Dvector.html#method-c-5B-5D">::[]</a>
    
    <li ><a href="Dvector.html#method-c-_load">::_load</a>
    
    <li ><a href="Dvector.html#method-c-compute_formula">::compute_formula</a>
    
    <li ><a href="Dvector.html#method-c-create_pm_cubic_interpolant">::create_pm_cubic_interpolant</a>
    
    <li ><a href="Dvector.html#method-c-create_spline_interpolant">::create_spline_interpolant</a>
    
    <li ><a href="Dvector.html#method-c-fancy_read">::fancy_read</a>
    
    <li ><a href="Dvector.html#method-c-fast_fancy_read">::fast_fancy_read</a>
    
    <li ><a href="Dvector.html#method-c-from_na">::from_na</a>
    
    <li ><a href="Dvector.html#method-c-is_a_dvector">::is_a_dvector</a>
    
    <li ><a href="Dvector.html#method-c-linear_interpolate">::linear_interpolate</a>
    
    <li ><a href="Dvector.html#method-c-max_of_many">::max_of_many</a>
    
    <li ><a href="Dvector.html#method-c-min_of_many">::min_of_many</a>
    
    <li ><a href="Dvector.html#method-c-new">::new</a>
    
    <li ><a href="Dvector.html#method-c-old_fancy_read">::old_fancy_read</a>
    
    <li ><a href="Dvector.html#method-c-pm_cubic_interpolate">::pm_cubic_interpolate</a>
    
    <li ><a href="Dvector.html#method-c-read">::read</a>
    
    <li ><a href="Dvector.html#method-c-read_columns">::read_columns</a>
    
    <li ><a href="Dvector.html#method-c-read_row">::read_row</a>
    
    <li ><a href="Dvector.html#method-c-read_rows">::read_rows</a>
    
    <li ><a href="Dvector.html#method-c-spline_interpolate">::spline_interpolate</a>
    
    <li ><a href="Dvector.html#method-c-write">::write</a>
    
    <li ><a href="Dvector.html#method-i-25">#%</a>
    
    <li ><a href="Dvector.html#method-i-2A">#*</a>
    
    <li ><a href="Dvector.html#method-i-2A-2A">#**</a>
    
    <li ><a href="Dvector.html#method-i-2B">#+</a>
    
    <li ><a href="Dvector.html#method-i-2D">#-</a>
    
    <li ><a href="Dvector.html#method-i-2D-40">#-@</a>
    
    <li ><a href="Dvector.html#method-i-2F">#/</a>
    
    <li ><a href="Dvector.html#method-i-3C-3C">#&lt;&lt;</a>
    
    <li ><a href="Dvector.html#method-i-3C-3D-3E">#&lt;=&gt;</a>
    
    <li ><a href="Dvector.html#method-i-3D-3D">#==</a>
    
    <li ><a href="Dvector.html#method-i-5B-5D">#[]</a>
    
    <li ><a href="Dvector.html#method-i-5B-5D-3D">#[]=</a>
    
    <li ><a href="Dvector.html#method-i-_dump">#_dump</a>
    
    <li ><a href="Dvector.html#method-i-abs">#abs</a>
    
    <li ><a href="Dvector.html#method-i-abs-21">#abs!</a>
    
    <li ><a href="Dvector.html#method-i-acos">#acos</a>
    
    <li ><a href="Dvector.html#method-i-acos-21">#acos!</a>
    
    <li ><a href="Dvector.html#method-i-acosh">#acosh</a>
    
    <li ><a href="Dvector.html#method-i-acosh-21">#acosh!</a>
    
    <li ><a href="Dvector.html#method-i-add">#add</a>
    
    <li ><a href="Dvector.html#method-i-add-21">#add!</a>
    
    <li ><a href="Dvector.html#method-i-as_exponent_of">#as_exponent_of</a>
    
    <li ><a href="Dvector.html#method-i-as_exponent_of-21">#as_exponent_of!</a>
    
    <li ><a href="Dvector.html#method-i-asin">#asin</a>
    
    <li ><a href="Dvector.html#method-i-asin-21">#asin!</a>
    
    <li ><a href="Dvector.html#method-i-asinh">#asinh</a>
    
    <li ><a href="Dvector.html#method-i-asinh-21">#asinh!</a>
    
    <li ><a href="Dvector.html#method-i-at">#at</a>
    
    <li ><a href="Dvector.html#method-i-atan">#atan</a>
    
    <li ><a href="Dvector.html#method-i-atan-21">#atan!</a>
    
    <li ><a href="Dvector.html#method-i-atan2">#atan2</a>
    
    <li ><a href="Dvector.html#method-i-atan2-21">#atan2!</a>
    
    <li ><a href="Dvector.html#method-i-atanh">#atanh</a>
    
    <li ><a href="Dvector.html#method-i-atanh-21">#atanh!</a>
    
    <li ><a href="Dvector.html#method-i-bounds">#bounds</a>
    
    <li ><a href="Dvector.html#method-i-ceil">#ceil</a>
    
    <li ><a href="Dvector.html#method-i-ceil-21">#ceil!</a>
    
    <li ><a href="Dvector.html#method-i-clean-3F">#clean?</a>
    
    <li ><a href="Dvector.html#method-i-clear">#clear</a>
    
    <li ><a href="Dvector.html#method-i-collect">#collect</a>
    
    <li ><a href="Dvector.html#method-i-collect-21">#collect!</a>
    
    <li ><a href="Dvector.html#method-i-collect2">#collect2</a>
    
    <li ><a href="Dvector.html#method-i-collect2-21">#collect2!</a>
    
    <li ><a href="Dvector.html#method-i-concat">#concat</a>
    
    <li ><a href="Dvector.html#method-i-convolve">#convolve</a>
    
    <li ><a href="Dvector.html#method-i-cos">#cos</a>
    
    <li ><a href="Dvector.html#method-i-cos-21">#cos!</a>
    
    <li ><a href="Dvector.html#method-i-cosh">#cosh</a>
    
    <li ><a href="Dvector.html#method-i-cosh-21">#cosh!</a>
    
    <li ><a href="Dvector.html#method-i-delete">#delete</a>
    
    <li ><a href="Dvector.html#method-i-delete_at">#delete_at</a>
    
    <li ><a href="Dvector.html#method-i-delete_if">#delete_if</a>
    
    <li ><a href="Dvector.html#method-i-dirty">#dirty</a>
    
    <li ><a href="Dvector.html#method-i-dirty-3D">#dirty=</a>
    
    <li ><a href="Dvector.html#method-i-dirty-3F">#dirty?</a>
    
    <li ><a href="Dvector.html#method-i-div">#div</a>
    
    <li ><a href="Dvector.html#method-i-div-21">#div!</a>
    
    <li ><a href="Dvector.html#method-i-dot">#dot</a>
    
    <li ><a href="Dvector.html#method-i-dup">#dup</a>
    
    <li ><a href="Dvector.html#method-i-each">#each</a>
    
    <li ><a href="Dvector.html#method-i-each2">#each2</a>
    
    <li ><a href="Dvector.html#method-i-each2_with_index">#each2_with_index</a>
    
    <li ><a href="Dvector.html#method-i-each3">#each3</a>
    
    <li ><a href="Dvector.html#method-i-each3_with_index">#each3_with_index</a>
    
    <li ><a href="Dvector.html#method-i-each_index">#each_index</a>
    
    <li ><a href="Dvector.html#method-i-each_with_index">#each_with_index</a>
    
    <li ><a href="Dvector.html#method-i-empty-3F">#empty?</a>
    
    <li ><a href="Dvector.html#method-i-eql-3F">#eql?</a>
    
    <li ><a href="Dvector.html#method-i-exp">#exp</a>
    
    <li ><a href="Dvector.html#method-i-exp-21">#exp!</a>
    
    <li ><a href="Dvector.html#method-i-exp10">#exp10</a>
    
    <li ><a href="Dvector.html#method-i-exp10-21">#exp10!</a>
    
    <li ><a href="Dvector.html#method-i-extrema">#extrema</a>
    
    <li ><a href="Dvector.html#method-i-fetch">#fetch</a>
    
    <li ><a href="Dvector.html#method-i-fft-21">#fft!</a>
    
    <li ><a href="Dvector.html#method-i-fft_conj-21">#fft_conj!</a>
    
    <li ><a href="Dvector.html#method-i-fft_mul-21">#fft_mul!</a>
    
    <li ><a href="Dvector.html#method-i-fft_spectrum">#fft_spectrum</a>
    
    <li ><a href="Dvector.html#method-i-fill">#fill</a>
    
    <li ><a href="Dvector.html#method-i-first">#first</a>
    
    <li ><a href="Dvector.html#method-i-floor">#floor</a>
    
    <li ><a href="Dvector.html#method-i-floor-21">#floor!</a>
    
    <li ><a href="Dvector.html#method-i-freeze">#freeze</a>
    
    <li ><a href="Dvector.html#method-i-frozen-3F">#frozen?</a>
    
    <li ><a href="Dvector.html#method-i-include-3F">#include?</a>
    
    <li ><a href="Dvector.html#method-i-index">#index</a>
    
    <li ><a href="Dvector.html#method-i-initialize_copy">#initialize_copy</a>
    
    <li ><a href="Dvector.html#method-i-insert">#insert</a>
    
    <li ><a href="Dvector.html#method-i-inspect">#inspect</a>
    
    <li ><a href="Dvector.html#method-i-inv">#inv</a>
    
    <li ><a href="Dvector.html#method-i-inv-21">#inv!</a>
    
    <li ><a href="Dvector.html#method-i-join">#join</a>
    
    <li ><a href="Dvector.html#method-i-last">#last</a>
    
    <li ><a href="Dvector.html#method-i-length">#length</a>
    
    <li ><a href="Dvector.html#method-i-log">#log</a>
    
    <li ><a href="Dvector.html#method-i-log-21">#log!</a>
    
    <li ><a href="Dvector.html#method-i-log10">#log10</a>
    
    <li ><a href="Dvector.html#method-i-log10-21">#log10!</a>
    
    <li ><a href="Dvector.html#method-i-make_bezier_control_points_for_cubic_in_x">#make_bezier_control_points_for_cubic_in_x</a>
    
    <li ><a href="Dvector.html#method-i-map">#map</a>
    
    <li ><a href="Dvector.html#method-i-map-21">#map!</a>
    
    <li ><a href="Dvector.html#method-i-map2">#map2</a>
    
    <li ><a href="Dvector.html#method-i-map2-21">#map2!</a>
    
    <li ><a href="Dvector.html#method-i-max">#max</a>
    
    <li ><a href="Dvector.html#method-i-max_lt">#max_lt</a>
    
    <li ><a href="Dvector.html#method-i-min">#min</a>
    
    <li ><a href="Dvector.html#method-i-min_gt">#min_gt</a>
    
    <li ><a href="Dvector.html#method-i-minus">#minus</a>
    
    <li ><a href="Dvector.html#method-i-minus-21">#minus!</a>
    
    <li ><a href="Dvector.html#method-i-mod">#mod</a>
    
    <li ><a href="Dvector.html#method-i-mod-21">#mod!</a>
    
    <li ><a href="Dvector.html#method-i-modulo">#modulo</a>
    
    <li ><a href="Dvector.html#method-i-modulo-21">#modulo!</a>
    
    <li ><a href="Dvector.html#method-i-mul">#mul</a>
    
    <li ><a href="Dvector.html#method-i-mul-21">#mul!</a>
    
    <li ><a href="Dvector.html#method-i-neg">#neg</a>
    
    <li ><a href="Dvector.html#method-i-neg-21">#neg!</a>
    
    <li ><a href="Dvector.html#method-i-nitems">#nitems</a>
    
    <li ><a href="Dvector.html#method-i-plus">#plus</a>
    
    <li ><a href="Dvector.html#method-i-plus-21">#plus!</a>
    
    <li ><a href="Dvector.html#method-i-pop">#pop</a>
    
    <li ><a href="Dvector.html#method-i-pow">#pow</a>
    
    <li ><a href="Dvector.html#method-i-pow-21">#pow!</a>
    
    <li ><a href="Dvector.html#method-i-prune">#prune</a>
    
    <li ><a href="Dvector.html#method-i-prune-21">#prune!</a>
    
    <li ><a href="Dvector.html#method-i-push">#push</a>
    
    <li ><a href="Dvector.html#method-i-raised_to">#raised_to</a>
    
    <li ><a href="Dvector.html#method-i-raised_to-21">#raised_to!</a>
    
    <li ><a href="Dvector.html#method-i-reject">#reject</a>
    
    <li ><a href="Dvector.html#method-i-reject-21">#reject!</a>
    
    <li ><a href="Dvector.html#method-i-remainder">#remainder</a>
    
    <li ><a href="Dvector.html#method-i-remainder-21">#remainder!</a>
    
    <li ><a href="Dvector.html#method-i-replace">#replace</a>
    
    <li ><a href="Dvector.html#method-i-resize">#resize</a>
    
    <li ><a href="Dvector.html#method-i-reverse">#reverse</a>
    
    <li ><a href="Dvector.html#method-i-reverse-21">#reverse!</a>
    
    <li ><a href="Dvector.html#method-i-reverse_each">#reverse_each</a>
    
    <li ><a href="Dvector.html#method-i-reverse_each2">#reverse_each2</a>
    
    <li ><a href="Dvector.html#method-i-reverse_each2_with_index">#reverse_each2_with_index</a>
    
    <li ><a href="Dvector.html#method-i-reverse_each3">#reverse_each3</a>
    
    <li ><a href="Dvector.html#method-i-reverse_each3_with_index">#reverse_each3_with_index</a>
    
    <li ><a href="Dvector.html#method-i-reverse_each_index">#reverse_each_index</a>
    
    <li ><a href="Dvector.html#method-i-reverse_each_with_index">#reverse_each_with_index</a>
    
    <li ><a href="Dvector.html#method-i-rfft-21">#rfft!</a>
    
    <li ><a href="Dvector.html#method-i-rindex">#rindex</a>
    
    <li ><a href="Dvector.html#method-i-round">#round</a>
    
    <li ><a href="Dvector.html#method-i-round-21">#round!</a>
    
    <li ><a href="Dvector.html#method-i-safe_acos">#safe_acos</a>
    
    <li ><a href="Dvector.html#method-i-safe_acos-21">#safe_acos!</a>
    
    <li ><a href="Dvector.html#method-i-safe_asin">#safe_asin</a>
    
    <li ><a href="Dvector.html#method-i-safe_asin-21">#safe_asin!</a>
    
    <li ><a href="Dvector.html#method-i-safe_inv">#safe_inv</a>
    
    <li ><a href="Dvector.html#method-i-safe_inv-21">#safe_inv!</a>
    
    <li ><a href="Dvector.html#method-i-safe_log">#safe_log</a>
    
    <li ><a href="Dvector.html#method-i-safe_log-21">#safe_log!</a>
    
    <li ><a href="Dvector.html#method-i-safe_log10">#safe_log10</a>
    
    <li ><a href="Dvector.html#method-i-safe_log10-21">#safe_log10!</a>
    
    <li ><a href="Dvector.html#method-i-safe_sqrt">#safe_sqrt</a>
    
    <li ><a href="Dvector.html#method-i-safe_sqrt-21">#safe_sqrt!</a>
    
    <li ><a href="Dvector.html#method-i-select">#select</a>
    
    <li ><a href="Dvector.html#method-i-set">#set</a>
    
    <li ><a href="Dvector.html#method-i-shift">#shift</a>
    
    <li ><a href="Dvector.html#method-i-sin">#sin</a>
    
    <li ><a href="Dvector.html#method-i-sin-21">#sin!</a>
    
    <li ><a href="Dvector.html#method-i-sinh">#sinh</a>
    
    <li ><a href="Dvector.html#method-i-sinh-21">#sinh!</a>
    
    <li ><a href="Dvector.html#method-i-size">#size</a>
    
    <li ><a href="Dvector.html#method-i-slice">#slice</a>
    
    <li ><a href="Dvector.html#method-i-slice-21">#slice!</a>
    
    <li ><a href="Dvector.html#method-i-sort">#sort</a>
    
    <li ><a href="Dvector.html#method-i-sort-21">#sort!</a>
    
    <li ><a href="Dvector.html#method-i-sqrt">#sqrt</a>
    
    <li ><a href="Dvector.html#method-i-sqrt-21">#sqrt!</a>
    
    <li ><a href="Dvector.html#method-i-sub">#sub</a>
    
    <li ><a href="Dvector.html#method-i-sub-21">#sub!</a>
    
    <li ><a href="Dvector.html#method-i-sum">#sum</a>
    
    <li ><a href="Dvector.html#method-i-tan">#tan</a>
    
    <li ><a href="Dvector.html#method-i-tan-21">#tan!</a>
    
    <li ><a href="Dvector.html#method-i-tanh">#tanh</a>
    
    <li ><a href="Dvector.html#method-i-tanh-21">#tanh!</a>
    
    <li ><a href="Dvector.html#method-i-times">#times</a>
    
    <li ><a href="Dvector.html#method-i-times-21">#times!</a>
    
    <li ><a href="Dvector.html#method-i-to_a">#to_a</a>
    
    <li ><a href="Dvector.html#method-i-to_ary">#to_ary</a>
    
    <li ><a href="Dvector.html#method-i-to_dvector">#to_dvector</a>
    
    <li ><a href="Dvector.html#method-i-to_na">#to_na</a>
    
    <li ><a href="Dvector.html#method-i-to_s">#to_s</a>
    
    <li ><a href="Dvector.html#method-i-tridag">#tridag</a>
    
    <li ><a href="Dvector.html#method-i-trim">#trim</a>
    
    <li ><a href="Dvector.html#method-i-trim-21">#trim!</a>
    
    <li ><a href="Dvector.html#method-i-uniq">#uniq</a>
    
    <li ><a href="Dvector.html#method-i-uniq-21">#uniq!</a>
    
    <li ><a href="Dvector.html#method-i-unshift">#unshift</a>
    
    <li ><a href="Dvector.html#method-i-values_at">#values_at</a>
    
    <li ><a href="Dvector.html#method-i-vector_length">#vector_length</a>
    
    <li ><a href="Dvector.html#method-i-where_closest">#where_closest</a>
    
    <li ><a href="Dvector.html#method-i-where_eq">#where_eq</a>
    
    <li ><a href="Dvector.html#method-i-where_first_closest">#where_first_closest</a>
    
    <li ><a href="Dvector.html#method-i-where_first_eq">#where_first_eq</a>
    
    <li ><a href="Dvector.html#method-i-where_first_ge">#where_first_ge</a>
    
    <li ><a href="Dvector.html#method-i-where_first_gt">#where_first_gt</a>
    
    <li ><a href="Dvector.html#method-i-where_first_le">#where_first_le</a>
    
    <li ><a href="Dvector.html#method-i-where_first_lt">#where_first_lt</a>
    
    <li ><a href="Dvector.html#method-i-where_first_max">#where_first_max</a>
    
    <li ><a href="Dvector.html#method-i-where_first_min">#where_first_min</a>
    
    <li ><a href="Dvector.html#method-i-where_first_ne">#where_first_ne</a>
    
    <li ><a href="Dvector.html#method-i-where_ge">#where_ge</a>
    
    <li ><a href="Dvector.html#method-i-where_gt">#where_gt</a>
    
    <li ><a href="Dvector.html#method-i-where_last_closest">#where_last_closest</a>
    
    <li ><a href="Dvector.html#method-i-where_last_eq">#where_last_eq</a>
    
    <li ><a href="Dvector.html#method-i-where_last_ge">#where_last_ge</a>
    
    <li ><a href="Dvector.html#method-i-where_last_gt">#where_last_gt</a>
    
    <li ><a href="Dvector.html#method-i-where_last_le">#where_last_le</a>
    
    <li ><a href="Dvector.html#method-i-where_last_lt">#where_last_lt</a>
    
    <li ><a href="Dvector.html#method-i-where_last_max">#where_last_max</a>
    
    <li ><a href="Dvector.html#method-i-where_last_min">#where_last_min</a>
    
    <li ><a href="Dvector.html#method-i-where_last_ne">#where_last_ne</a>
    
    <li ><a href="Dvector.html#method-i-where_le">#where_le</a>
    
    <li ><a href="Dvector.html#method-i-where_lt">#where_lt</a>
    
    <li ><a href="Dvector.html#method-i-where_max">#where_max</a>
    
    <li ><a href="Dvector.html#method-i-where_min">#where_min</a>
    
    <li ><a href="Dvector.html#method-i-where_ne">#where_ne</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Dobjects::Dvector">
  <h1 id="class-Dobjects::Dvector" class="class">
    class Dobjects::Dvector
  </h1>

  <section class="description">
    
<p>Dvectors are a specialized implementation of one-dimensional arrays of
double precision floating point numbers.  They are intended for use in
applications needing efficient processing of large vectors of numeric data.
Essentially any of the operations you might do with a 1D Ruby Array of
numbers can also be done with a <a href="Dvector.html">Dvector</a>. Just
like Arrays, <a href="Dvector.html">Dvector</a> indexing starts at 0.  A
negative index is  assumed to be relative to the end of the vector—that is,
an index of -1  indicates the last element of the vector, -2 is the next to
last  element in the vector, and so on.  Element reference and element
assignment are the same as for Arrays, allowing for (start,length) or
(range) as well as for simple indexing.  All of the other Array operations
that make sense for a 1D array of numbers are also provided for Dvectors. 
For example, you can “fetch” or “fill” with Dvectors, but there is no
“assoc” or “compact” for them since one looks for arrays as elements and
the other looks for <code>nil</code> elements, neither of which are found
in Dvectors.</p>

<p>In addition to the usual Array methods, there are a variety of others that
operate on the contents of the entire vector without the use of explicit
iterators.  These routines are crucial for efficient processing of large
vectors.  For example, “<em>vec</em>.sqrt” will create a vector of square
roots of entries in  <em>vec</em> more efficiently than the semantically
equivalent form “<em>vec</em>.collect { |x| sqrt(x) }”.</p>

<p>All of the numeric methods also have  &#39;bang&#39; versions that modify
the contents of the vector in place; for example, “<em>vec</em>.sqrt!” is
more efficient than “<em>vec</em> = <em>vec</em>.sqrt”.  By providing
implicit iterators and in-place modification, Dvectors make it possible to
operate on large vectors of doubles in Ruby at speeds closely approaching a
C implementation.</p>

<p>As a final example, for diehards only, say we have large vectors holding
values of abundances of total helium (<em>xhe</em>), singly ionized helium
(<em>xhe1</em>), and doubly ionized helium (<em>xhe2</em>). We&#39;re
missing the values for neutral helium, but that is just what&#39;s left of
total helium after you subtract the two ionized forms, so it is easy to
compute it.  Finally, we need to calculate the log of the abundance of
neutral helium and store it in another vector (<em>log_xhe0</em>).</p>

<p>If we don&#39;t care about creating work for the garbage collector, we can
simply do this</p>

<pre>log_xhe0 = (xhe - xhe1 - xhe2).log10</pre>

<p>This works, but it creates multiple temporary vectors for intermediate
results. If, like me, you&#39;re compulsive about efficiency, you can do
the whole thing with no garbage created at all:</p>

<pre>log_xhe0 = Dvector.new
log_xhe0.replace(xhe).sub!(xhe1).sub!(xhe2).log10!</pre>

<p>This copies <em>xhe</em> to <em>log_xhe0</em>, subtracts <em>xhe1</em> and
<em>xhe2</em> from <em>log_xhe0</em> in place, and then takes the
<code>log</code>, also in place.  It&#39;s not pretty, but it is efficient
– use if needed.</p>

<p>Please report problems with the <a href="Dvector.html">Dvector</a>
extension to the <code>tioga-users</code> at <code>rubyforge.org</code>
mailing list. [Note: for N-dimensional arrays or arrays of complex numbers
or integers as well as doubles, along with a variety of matrix operations,
check out the <a
href="http://www.ir.isas.ac.jp/~masa/ruby/index-e.html">NArray</a>
extension.]</p>

<p><a href="Dvector.html">Dvector</a> now also prides itselfs with a _dump and
a _load function, which means you can Marshal them.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="FANCY_READ_DEFAULTS">FANCY_READ_DEFAULTS
        
        <dd><p><a href="Dvector.html#method-c-fancy_read">::fancy_read</a>&#39;s defaults
options. See that function for more details</p>
        
      
        <dt id="WRITE_DEFAULTS">WRITE_DEFAULTS
        
        <dd>
        
      
      </dl>
    </section>
    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-5B-5D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">[]</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a new <a href="Dvector.html">Dvector</a> populated with the given
objects.</p>

<pre>Dvector.[]( 1, 2, 3, 4 )      -&gt; a_dvector
Dvector[ 1, 2, 3, 4 ]         -&gt; a_dvector</pre>
          
          

          
          <div class="method-source-code" id="5B-5D-source">
            <pre>static VALUE dvector_s_create(int argc, VALUE *argv, VALUE klass) {
   VALUE ary = make_new_dvector(klass, argc, argc);
   Dvector *d = Get_Dvector(ary);
   if (argc &lt; 0) {
      rb_raise(rb_eArgError, &quot;negative number of arguments&quot;);
   }
   ary_to_dvector(argv, argc, d-&gt;ptr);
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-_load" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">_load</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Called by the marshalling mechanism to retrieve a permanent copy of a  <a
href="Dvector.html">Dvector</a>.</p>
          
          

          
          <div class="method-source-code" id="_load-source">
            <pre>VALUE dvector_load(VALUE klass, VALUE str)
{
  VALUE ret = Qnil;
  VALUE s = StringValue(str);
  unsigned char * buf = (unsigned char *) StringValuePtr(s);
  unsigned char * dest = buf + RSTRING_LEN(s);
  unsigned i; /* for GET_UNSIGNED */
  unsigned tmp = 0;
  double * data;
  /*  depending on the first byte, the decoding will be different */
  switch(*(buf++)) 
    {
    case 1:
      GET_UNSIGNED(tmp, buf);
      /* create a new Dvector with the right size */
      ret = rb_funcall(cDvector, rb_intern(&quot;new&quot;), 1, UINT2NUM(tmp));
      data = Dvector_Data_for_Write(ret, NULL);
      for(i = 0; i&lt; tmp; i++)
        {
          if(buf + 8 &gt; dest)
            {
              rb_raise(rb_eRuntimeError, 
                       &quot;corrupted data given to Dvector._load&quot;);
              break;
            }  
          else 
            {
              data[i] = get_double(buf);
              buf += 8;
            }
        }
      break;
    default:
      rb_raise(rb_eRuntimeError, &quot;corrupted data given to Dvector._load&quot;);
    }
  return ret;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-compute_formula" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">compute_formula</span><span
            class="method-args">(formula, a, modules = [])</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>This function is a rudimentary formula computing stuff. Give it a text
<em>formula</em> and an array of Dvectors (<em>a</em>), and it returns a <a
href="Dvector.html">Dvector</a> with the result. The formula should contain
the following;</p>
<dl class="rdoc-list note-list"><dt><a href="https://tioga.sourceforge.net/doc/Dobjects/n">column</a>
<dd>
<p>represents the current element of the n th <a
href="Dvector.html">Dvector</a> of the array</p>
</dd></dl>

<p>This is just a try, and should be implemented in C rather than in Ruby. But
if you&#39;re looking for simplicity, here you go ;-) !</p>

<p><em>modules</em> are the modules you would wish the evaluator to
<code>include</code>.  This feature enables one to make sure custom
functions are included</p>
          
          

          
          <div class="method-source-code" id="compute_formula-source">
            <pre><span class="ruby-comment"># File lib/Dobjects/Dvector_extras.rb, line 223</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">compute_formula</span>(<span class="ruby-identifier">formula</span>, <span class="ruby-identifier">a</span>, <span class="ruby-identifier">modules</span> = []) <span class="ruby-comment"># :doc:</span>

  <span class="ruby-identifier">evaluator</span> = <span class="ruby-constant">MathEvaluator</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">formula</span>, <span class="ruby-string">&quot;column&quot;</span>, <span class="ruby-identifier">modules</span>)
  <span class="ruby-comment"># if we reach this place, it means that there a no big syntax errors ;-)</span>
  
  <span class="ruby-comment"># we now need to inspect the array given, and make sure that there is</span>
  <span class="ruby-comment"># and transform it into a clean stuff (an array with only Dvectors and</span>
  <span class="ruby-comment"># nil elements).</span>
  
  <span class="ruby-identifier">target</span> = []
  <span class="ruby-identifier">last</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">a</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">elem</span><span class="ruby-operator">|</span> 
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">elem</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">Dvector</span>
      <span class="ruby-identifier">target</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">elem</span>
      <span class="ruby-identifier">last</span> = <span class="ruby-identifier">elem</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">target</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">end</span>
  }
  
  <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;No Dvector found&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">last</span>
  
  <span class="ruby-comment"># we check all the vectors have the same length</span>
  <span class="ruby-identifier">target</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> 
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">last</span>.<span class="ruby-identifier">length</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Dvectors should have all the same length !&quot;</span> 
    <span class="ruby-keyword">end</span>
  }
  
  <span class="ruby-identifier">res</span> = <span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">new</span>
  
  <span class="ruby-identifier">last</span>.<span class="ruby-identifier">each_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">args</span> = <span class="ruby-identifier">target</span>.<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">val</span><span class="ruby-operator">|</span> 
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">val</span>
        <span class="ruby-identifier">val</span>[<span class="ruby-identifier">i</span>]
      <span class="ruby-keyword">else</span> 
        <span class="ruby-keyword">nil</span>
      <span class="ruby-keyword">end</span>
    }
    <span class="ruby-comment"># we add the index at the beginning:</span>
    <span class="ruby-comment">#         args.unshift(i) </span>
    <span class="ruby-comment"># Commented out for simplicity</span>
    
    <span class="ruby-comment"># then we call the block:</span>
    <span class="ruby-identifier">elem</span> = <span class="ruby-identifier">evaluator</span>.<span class="ruby-identifier">compute</span>(<span class="ruby-identifier">args</span>)
    <span class="ruby-identifier">res</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">elem</span>
  }
  
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">res</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-create_pm_cubic_interpolant" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            create_pm_cubic_interpolant(xs, ys) &rarr;  interpolant
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Uses Dvectors <em>xs</em> and <em>ys</em> to create a cubic pm_cubic
interpolant.  The <em>xs</em> must be given in ascending order. The
interpolant is an array of Dvectors: [Xs, Ys, As, Bs, Cs]. For x between <a
href="https://tioga.sourceforge.net/doc/Dobjects/j">Xs</a> and <a href="https://tioga.sourceforge.net/doc/Dobjects/j+1">Xs</a>, let dx = x - <a href="https://tioga.sourceforge.net/doc/Dobjects/j">Xs</a>,
and find interpolated y for x by y = <a href="https://tioga.sourceforge.net/doc/Dobjects/j">As</a>*dx^3 + <a
href="https://tioga.sourceforge.net/doc/Dobjects/j">Bs</a>*dx^2 + <a href="https://tioga.sourceforge.net/doc/Dobjects/j">Cs</a>*dx + <a href="https://tioga.sourceforge.net/doc/Dobjects/j">Ys</a>. pm_cubic
algorithms derived from Steffen, M., “A simple method for monotonic
interpolation in one dimension”,</p>

<pre>Astron. Astrophys., (239) 1990, 443-450.</pre>
          
          

          
          <div class="method-source-code" id="create_pm_cubic_interpolant-source">
            <pre>VALUE dvector_create_pm_cubic_interpolant(int argc, VALUE *argv, VALUE klass) {
   if (argc != 2)
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d) for create_pm_cubic_interpolant&quot;, argc);
   klass = Qnil;
   VALUE Xs = argv[0], Ys = argv[1];
   long xdlen, ydlen;
   double *X_data = Dvector_Data_for_Read(Xs, &amp;xdlen);
   double *Y_data = Dvector_Data_for_Read(Ys, &amp;ydlen);
   if (X_data == NULL || Y_data == NULL || xdlen != ydlen)
      rb_raise(rb_eArgError, &quot;Data for create_pm_cubic_interpolant must be equal length Dvectors&quot;);
   int nx = xdlen;
   VALUE As = Dvector_Create(), Bs = Dvector_Create(), Cs = Dvector_Create();
   double *As_data = Dvector_Data_Resize(As, nx);
   double *Bs_data = Dvector_Data_Resize(Bs, nx);
   double *Cs_data = Dvector_Data_Resize(Cs, nx);
   c_dvector_create_pm_cubic_interpolant(nx, X_data, Y_data, As_data, Bs_data, Cs_data);
   VALUE result = rb_ary_new2(5);
   rb_ary_store(result, 0, Xs);
   rb_ary_store(result, 1, Ys);
   rb_ary_store(result, 2, As);
   rb_ary_store(result, 3, Bs);
   rb_ary_store(result, 4, Cs);
   return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-create_spline_interpolant" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            create_spline_interpolant(xs, ys, start_clamped, start_slope, end_clamped, end_slope) &rarr;  interpolant
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Uses Dvectors <em>xs</em> and <em>ys</em> to create a cubic spline
interpolant.  The <em>xs</em> must be given in ascending order. There is a
boundary condition choice to be made for each end concerning the slope.  If
clamped is true, the correspdoning slope argument value sets the slope.  If
clamped is false (known as a “free” or “natural” spline), the 2nd
derivative is set to 0 and the slope is determined by the fit.  In this
case, the corresponding slope argument is ignored.  The interpolant is an
array of Dvectors: [Xs, Ys, As, Bs, Cs]. For x between <a href="https://tioga.sourceforge.net/doc/Dobjects/j">Xs</a>
and <a href="https://tioga.sourceforge.net/doc/Dobjects/j+1">Xs</a>, let dx = x - <a href="https://tioga.sourceforge.net/doc/Dobjects/j">Xs</a>, and find
interpolated y for x by y = <a href="https://tioga.sourceforge.net/doc/Dobjects/j">As</a>*dx^3 + <a
href="https://tioga.sourceforge.net/doc/Dobjects/j">Bs</a>*dx^2 + <a href="https://tioga.sourceforge.net/doc/Dobjects/j">Cs</a>*dx + <a href="https://tioga.sourceforge.net/doc/Dobjects/j">Ys</a>. (Spline
algorithms derived from Burden &amp; Faires, Numerical Analysis, 4th
edition, pp 131 and following.)</p>
          
          

          
          <div class="method-source-code" id="create_spline_interpolant-source">
            <pre>VALUE dvector_create_spline_interpolant(int argc, VALUE *argv, VALUE klass) {
   if (argc != 6)
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d) for create_spline_interpolant&quot;, argc);
   klass = Qnil;
   VALUE Xs = argv[0], Ys = argv[1];
   VALUE start_clamped = argv[2], start_slope = argv[3], end_clamped = argv[4], end_slope = argv[5];
   long xdlen, ydlen;
   double start = 0.0, end = 0.0;
   double *X_data = Dvector_Data_for_Read(Xs, &amp;xdlen);
   double *Y_data = Dvector_Data_for_Read(Ys, &amp;ydlen);
   if (X_data == NULL || Y_data == NULL || xdlen != ydlen)
      rb_raise(rb_eArgError, &quot;Data for create_spline_interpolant must be equal length Dvectors&quot;);
   bool start_flg = (start_clamped == Qtrue);
   bool end_flg = (end_clamped == Qtrue);
   if (start_flg) { start_slope = rb_Float(start_slope); start = NUM2DBL(start_slope); }
   if (end_flg) { end_slope = rb_Float(end_slope); end = NUM2DBL(end_slope); }
   int n_pts_data = xdlen;
   VALUE As = Dvector_Create(), Bs = Dvector_Create(), Cs = Dvector_Create();
   double *As_data = Dvector_Data_Resize(As, n_pts_data);
   double *Bs_data = Dvector_Data_Resize(Bs, n_pts_data);
   double *Cs_data = Dvector_Data_Resize(Cs, n_pts_data);
   c_dvector_create_spline_interpolant(n_pts_data, X_data, Y_data,
      start_flg, start, end_flg, end, As_data, Bs_data, Cs_data);
   VALUE result = rb_ary_new2(5);
   rb_ary_store(result, 0, Xs);
   rb_ary_store(result, 1, Ys);
   rb_ary_store(result, 2, As);
   rb_ary_store(result, 3, Bs);
   rb_ary_store(result, 4, Cs);
   return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-fancy_read" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">fancy_read</span><span
            class="method-args">(stream, cols = nil, opts = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>This function is a wrapper for fast_fancy_read that reflects the
look-and-feel of old_fancy_read</p>
          
          

          
          <div class="method-source-code" id="fancy_read-source">
            <pre><span class="ruby-comment"># File lib/Dobjects/Dvector_extras.rb, line 95</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">fancy_read</span>(<span class="ruby-identifier">stream</span>, <span class="ruby-identifier">cols</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">opts</span> = {}) <span class="ruby-comment"># :doc:</span>
  <span class="ruby-identifier">o</span> = <span class="ruby-constant">FANCY_READ_DEFAULTS</span>.<span class="ruby-identifier">dup</span>
  <span class="ruby-identifier">o</span>.<span class="ruby-identifier">update</span>(<span class="ruby-identifier">opts</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">stream</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">String</span>)
    <span class="ruby-identifier">stream</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">stream</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;&#39;stream&#39; should have a gets method&quot;</span>) <span class="ruby-keyword">unless</span> 
    <span class="ruby-identifier">stream</span>.<span class="ruby-identifier">respond_to?</span> <span class="ruby-value">:gets</span>
  
  <span class="ruby-identifier">o</span>[<span class="ruby-string">&#39;sep&#39;</span>] = <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">o</span>[<span class="ruby-string">&#39;sep&#39;</span>]) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">o</span>[<span class="ruby-string">&#39;sep&#39;</span>].<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">Regexp</span>
  
  <span class="ruby-identifier">res</span> = <span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">fast_fancy_read</span>(<span class="ruby-identifier">stream</span>, <span class="ruby-identifier">o</span>)

  <span class="ruby-comment"># Adding the index columns if necessary</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">o</span>[<span class="ruby-string">&quot;index_col&quot;</span>] 
    <span class="ruby-identifier">res</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">res</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">length</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>})
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">cols</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">cols</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">res</span>[<span class="ruby-identifier">i</span>] }
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">res</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-fast_fancy_read" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            fast_fancy_read(stream, options) &rarr; Array_of_Dvectors
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Reads data from an IO stream (or anything that supports a gets method) and
separate it into columns of data according to the <em>options</em>, a hash
holding the following elements (compulsory, but you can use <a
href="Dvector.html#FANCY_READ_DEFAULTS">FANCY_READ_DEFAULTS</a>):</p>

<pre>&#39;sep&#39;: a regular expression that separate the entries
&#39;comments&#39;: any line matching this will be skipped
&#39;skip_first&#39;: skips that many lines before reading anything
&#39;index_col&#39;: if true, the first column returned contains the
number of the line read
&#39;remove_space&#39;: whether to remove spaces at the beginning of a line.
&#39;comment_out&#39;: this should be an array into which the comments
 will be dumped one by one.
&#39;default&#39;:  what to put when nothing was found but a number must be used
&#39;last_col&#39;: when this is specified, it represents the last column which
 is read and parsed as numbers (0-based, so the 3rd column is 2). 
 The remaining is returned as text in one n+1 column
&#39;text_columns&#39;: if provided, it is an array of integers containing the 
0-based indices of columns to be parsed as text rather than numbers.</pre>

<p>In addition to these options that control the output, here are a few others
to tune memory allocation; these can strongly improve the performance (or
make it worse if you wish):</p>

<pre>&#39;initial_size&#39;: the initial size of the memory buffers: if there
are not more lines than that, no additional memory allocation/copy
occurs.</pre>
          
          

          
          <div class="method-source-code" id="fast_fancy_read-source">
            <pre>static VALUE dvector_fast_fancy_read(VALUE self, VALUE stream, VALUE options)
{
  /* First, we read up options: */
  double def = rb_num2dbl(rb_hash_aref(options, 
                                       rb_str_new2(&quot;default&quot;)));
  int remove_space = RTEST(rb_hash_aref(options, 
                                        rb_str_new2(&quot;remove_space&quot;)));
//  int index_col = RTEST(rb_hash_aref(options, 
//                                   rb_str_new2(&quot;index_col&quot;)));
  long skip_first = FIX2LONG(rb_hash_aref(options, 
                                          rb_str_new2(&quot;skip_first&quot;)));
  VALUE sep = rb_hash_aref(options, rb_str_new2(&quot;sep&quot;));
  VALUE comments = rb_hash_aref(options, rb_str_new2(&quot;comments&quot;));
  VALUE comment_out = rb_hash_aref(options, rb_str_new2(&quot;comment_out&quot;));

  /* Elements after that many columns  */
  VALUE lc = rb_hash_aref(options, rb_str_new2(&quot;last_col&quot;));
  long last_col = RTEST(lc) ? FIX2LONG(lc) : -1;
  VALUE text_columns = rb_hash_aref(options, rb_str_new2(&quot;text_columns&quot;));

  /* Then, some various variables: */
  VALUE line;

  ID chomp_id = rb_intern(&quot;chomp!&quot;);
  ID gets_id = rb_intern(&quot;gets&quot;);
  ID max_id = rb_intern(&quot;max&quot;);
  ID size_id = rb_intern(&quot;size&quot;);
  
  /* We compute the maximum number of text columns */
  long last_text_col = last_col+1;
  VALUE mx = RTEST(text_columns) ? rb_funcall(text_columns, max_id, 0) : Qnil;
  if(RTEST(mx) &amp;&amp; last_text_col &lt; 0) { /* Only taking the max into
                                          account if the last col
                                          stuff is not on */
    long d = FIX2LONG(mx);
    last_text_col = d;
  }


  /* array of Ruby arrays containing the text objects of interest */
  VALUE * text_cols = NULL;

  /*
    Handling of text columns.

    The number and position of text columns has to be known in
    advance. For each of those, the value of text_columns isn&#39;t Qnil,
    and the corresponding column is NULL.

   */
  if(last_text_col &gt;= 0) {
    text_cols = ALLOC_N(VALUE, last_text_col + 1);
    int i;
    for(i = 0; i &lt; last_text_col + 1; i++)
      text_cols[i] = Qnil;
    if(last_col &gt;= 0) {
      text_cols[last_col+1] = marked_array();
    }
    if(RTEST(mx)) {
      /* Todo */
      int sz = 
#ifdef RARRAY_LENINT
      RARRAY_LENINT(text_columns);
#else
      RARRAY_LEN(text_columns);
#endif
      int i;
      for(i = 0; i &lt;  sz; i++) {
        long idx = FIX2LONG(rb_ary_entry(text_columns, i));
        if(idx &gt;= 0 &amp;&amp; (last_col &lt; 0 || idx &lt; last_col)) {
          text_cols[idx] = marked_array();
        }
      }
    }
  }




  long line_number = 0;

  /* 
     Now come the fun part - rudimentary vectors management

     TODO: if the stream provides functionality to get its total size,
     it could be interesting to estimate the total number of lines
     based on some small heuristics
   */
  int nb_vectors = 0;           /* The number of vectors currently created */
  int current_size = 10;        /* The number of slots available */
  double ** vectors = ALLOC_N(double *, current_size);
  long index = 0;               /* The current index in the vectors */
  /* The size available in the vectors */
  int allocated_size = 
    FIX2LONG(rb_hash_aref(options, rb_str_new2(&quot;initial_size&quot;))); 


  int i;
  for(i = 0; i &lt; current_size; i++)
    vectors[i] = NULL;

  /* The return value */
  VALUE ary;

  /* We use a real gets so we can also use StringIO, for instance */
  while(RTEST(line = rb_funcall(stream, gets_id, 0))) {
    VALUE pre, post, match;
    const char * line_ptr;
    int col = 0;
    line_number++;
    /* Whether we should skip the line... */
    if(skip_first &gt;= line_number)
      continue;

    /* We check for a blank line using isspace: */
    line_ptr = StringValueCStr(line);
    while(line_ptr &amp;&amp; *line_ptr) {
      if(! isspace(*line_ptr))
        break;
      line_ptr++;
    }
    if(! *line_ptr)
      continue;                 /* We found a blank line  */
    if(remove_space)            /* We replace the contents of the line  */
      line = rb_str_new2(line_ptr);

    /* ... or a comment line */
    if(RTEST(comments) &amp;&amp; RTEST(rb_reg_match(comments, line))) {
      if(RTEST(comment_out))
        rb_ary_push(comment_out, line);
      continue;
    }

    /* Then, we remove the newline: */
    post = line;
    rb_funcall(post, chomp_id, 0);

    /* We iterate over the different portions between
       matches
    */
    while(RTEST(post)) {
      const char * a;
      char * b;
      if(RTEST(rb_reg_match(sep, post))) {
        match = rb_gv_get(&quot;$~&quot;);
        pre = rb_reg_match_pre(match);
        post = rb_reg_match_post(match);
      }
      else {
        pre = post;
        post = Qnil;
      }
      if(text_cols &amp;&amp; col &lt;= last_text_col &amp;&amp; RTEST(text_cols[col])) {
        rb_ary_push(text_cols[col], pre);
        if(col &gt;= nb_vectors) {
          nb_vectors ++;
          if(col &lt; current_size)
            vectors[col] = NULL;
        }
      }
      else {
        a = StringValueCStr(pre);
        double c = strtod(a, &amp;b);
        if(b == a) 
          c = def;
        if(col &gt;= nb_vectors) {
          /* We need to create a new vector */
          if(col &gt;= current_size) { /* Increase the available size */
            current_size = col + 5;
            REALLOC_N(vectors, double * , current_size);
          }
          for(; nb_vectors &lt;= col; nb_vectors++)
            vectors[nb_vectors] = NULL; /* default to NULL */
          
          double * vals = vectors[col] = ALLOC_N(double, allocated_size);
          /* Filling it with the default value */
          for(i = 0; i &lt; index; i++) {
            vals[i] = def;
          }
        }
        vectors[col][index] = c;
      }
      col++;
      if(last_col &gt;= 0 &amp;&amp; col &gt; last_col) {
        rb_ary_push(text_cols[last_col + 1], post);
        nb_vectors = col + 1;
        col++;
        break;
      }
    }
    /* Now, we finish the line */
    for(; col &lt; nb_vectors; col++) {
      if(text_cols &amp;&amp; col &lt;= last_text_col &amp;&amp; RTEST(text_cols[col]))
        rb_ary_push(text_cols[col], Qnil);
      else
        vectors[col][index] = def;
    }
    index++;
    /* Now, we reallocate memory if necessary */
    if(index &gt;= allocated_size) {
      allocated_size *= 2;      /* We double the size */
      for(col = 0; col &lt; nb_vectors; col++) {
        if(col &lt; current_size &amp;&amp; vectors[col])
          REALLOC_N(vectors[col], double, allocated_size);
      }
    }
  }
  /* Now, we make up the array */
  ary = rb_ary_new();
  for(i = 0; i &lt; nb_vectors; i++) {
    /* We create a vector */
    if(text_cols &amp;&amp; i &lt;= last_text_col &amp;&amp; RTEST(text_cols[i]))
      rb_ary_store(ary, i, text_cols[i]);
    else {
      rb_ary_store(ary, i, make_dvector_from_data(cDvector, index, vectors[i]));
      /* And free the memory */
      free(vectors[i]);
    }
  }
  free(vectors);
  if(text_cols)
    free(text_cols);
  return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-from_na" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">from_na</span><span
            class="method-args">(na)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>thanks to Dave MacMahon for <a
href="Dvector.html#method-c-from_na">::from_na</a> and <a
href="Dvector.html#method-i-to_na">#to_na</a> Create a <a
href="Dvector.html">Dvector</a> from an NArray.</p>
          
          

          
          <div class="method-source-code" id="from_na-source">
            <pre><span class="ruby-comment"># File lib/Dobjects/Dvector_extras.rb, line 64</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">from_na</span>(<span class="ruby-identifier">na</span>)
  <span class="ruby-identifier">_load</span>([<span class="ruby-value">1</span>, <span class="ruby-identifier">na</span>.<span class="ruby-identifier">length</span>, <span class="ruby-identifier">na</span>.<span class="ruby-identifier">to_s</span>].<span class="ruby-identifier">pack</span>(<span class="ruby-string">&#39;CIa*&#39;</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-is_a_dvector" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_a_dvector</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Checks if the given object is a <a href="Dvector.html">Dvector</a>. Mainly
here for testing purposes, as it corresponds to the internal
<code>is_a_dvector</code>.</p>
          
          

          
          <div class="method-source-code" id="is_a_dvector-source">
            <pre>VALUE dvector_is_a_dvector(VALUE self, VALUE obj)
{
  if(Is_Dvector(obj))
    return Qtrue;
  return Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-linear_interpolate" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            linear_interpolate(x, xs, ys)  &rarr;  y
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the <em>y</em> corresponding to <em>x</em> by linear interpolation
using the Dvectors <em>xs</em> and <em>ys</em>.</p>
          
          

          
          <div class="method-source-code" id="linear_interpolate-source">
            <pre>VALUE dvector_linear_interpolate(int argc, VALUE *argv, VALUE klass) {
   if (argc != 3)
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d) for linear_interpolate&quot;, argc);
   klass = Qnil;
   VALUE x = argv[0];
   VALUE Xs = argv[1];
   VALUE Ys = argv[2];
   Dvector *X_data = Get_Dvector(Xs);
   Dvector *Y_data = Get_Dvector(Ys);
   if (X_data-&gt;len &lt;= 0 || X_data-&gt;len != Y_data-&gt;len)
      rb_raise(rb_eArgError, &quot;Xs and Ys for linear_interpolate must be equal length Dvectors: xlen %ld ylen %ld.&quot;, 
         X_data-&gt;len, Y_data-&gt;len);
   x = rb_Float(x);
   double y = c_dvector_linear_interpolate(X_data-&gt;len, X_data-&gt;ptr, Y_data-&gt;ptr, NUM2DBL(x));
   return rb_float_new(y);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-max_of_many" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            max_of_many(ary)  &rarr;  number or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the maximum value held in the array of Dvectors (or
<code>nil</code> if <em>ary</em> is empty). Any <code>nil</code> entries in
<em>ary</em> are ignored.</p>
          
          

          
          <div class="method-source-code" id="max_of_many-source">
            <pre>VALUE dvector_max_of_many(VALUE klass, VALUE ary) {
   VALUE *ary_ptr;
   long ary_len, i;
   Dvector *d;
   double m=0.0, tmp;
   bool found_one = false;
   ary = rb_Array(ary);
   ary_ptr = RARRAY_PTR(ary);
   ary_len = RARRAY_LEN(ary);
   if (ary_len == 0) return Qnil;
   for (i = 0; i &lt; ary_len; i++) {
      if (ary_ptr[i] == Qnil) continue;
      d = Get_Dvector(ary_ptr[i]);
      if (d-&gt;len == 0) continue;
      if (!found_one) { m = c_dvector_max(d); found_one = true; }
      else {
         tmp = c_dvector_max(d);
         if (tmp &gt; m) m = tmp;
      }
   }
   if (!found_one) return Qnil;
   return rb_float_new(m);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-min_of_many" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            min_of_many(ary)  &rarr;  number or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the minimum value held in the array of Dvectors (or
<code>nil</code> if <em>ary</em> is empty). Any <code>nil</code> entries in
<em>ary</em> are ignored.</p>
          
          

          
          <div class="method-source-code" id="min_of_many-source">
            <pre>VALUE dvector_min_of_many(VALUE klass, VALUE ary) {
   VALUE *ary_ptr;
   long ary_len, i;
   Dvector *d;
   double m=0.0, tmp;
   bool found_one = false;
   ary = rb_Array(ary);
   ary_ptr = RARRAY_PTR(ary);
   ary_len = RARRAY_LEN(ary);
   if (ary_len == 0) return Qnil;
   for (i = 0; i &lt; ary_len; i++) {
      if (ary_ptr[i] == Qnil) continue;
      d = Get_Dvector(ary_ptr[i]);
      if (d-&gt;len == 0) continue;
      if (!found_one) { m = c_dvector_min(d); found_one = true; }
      else {
         tmp = c_dvector_min(d);
         if (tmp &lt; m) m = tmp;
      }
   }
   if (!found_one) return Qnil;
   return rb_float_new(m);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-new" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            new                          &rarr; a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(size=0, value=0)         &rarr; a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(other)                   &rarr; a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(size) {|index| block }   &rarr; a_dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new <a href="Dvector.html">Dvector</a>. In the first form, the
new vector is empty. In the second it is created with <em>size</em> copies
of <em>value</em> The third form creates a copy of the <em>other</em>
vector passed as a parameter (this can also be an Array). In the last form,
a vector of the given size is created. Each element in this vector is
calculated by passing the element&#39;s index to the given block and
storing the return value.</p>

<pre class="ruby"><span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">new</span>                       <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[]
<span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2</span>)                    <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">0</span>, <span class="ruby-value">0</span> ]
<span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>, <span class="ruby-value">-1</span>)                <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">-1</span>, <span class="ruby-value">-1</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>}     <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">5</span> ]
</pre>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre>VALUE dvector_initialize(int argc, VALUE *argv, VALUE ary) {
   long len;
   VALUE size, val;
   Dvector *d = dvector_modify(ary);
   if (rb_scan_args(argc, argv, &quot;02&quot;, &amp;size, &amp;val) == 0) {
      d-&gt;len = 0;
      if (rb_block_given_p()) {
         rb_warning(&quot;given block not used&quot;);
      }
      return ary;
   }
   if (argc == 1 &amp;&amp; !FIXNUM_P(size)) {
      val = dvector_check_array_type(size);
      if (!NIL_P(val)) {
         dvector_replace(ary, val);
         return ary;
      }
   }
   len = NUM2LONG(size);
   if (len &lt; 0) {
      rb_raise(rb_eArgError, &quot;negative array size&quot;);
   }
   if (len &gt; 0 &amp;&amp; len * (long)sizeof(VALUE) &lt;= len) {
      rb_raise(rb_eArgError, &quot;array size too big&quot;);
   }
   if (len &gt; d-&gt;capa) {
      REALLOC_N(d-&gt;ptr, double, len);
      d-&gt;capa = len;
   }
   if (rb_block_given_p()) {
      long i;
      if (argc == 2) {
         rb_warn(&quot;block supersedes default value argument&quot;);
      }
      for (i=0; i&lt;len; i++) {
         dvector_store(ary, i, rb_yield(LONG2NUM(i)));
         d-&gt;len = i + 1;
      }
   } else if (val == Qnil) {
      dvector_memfill(d-&gt;ptr, len, 0.0);
      d-&gt;len = len;
   } else {
      val = rb_Float(val);
      dvector_memfill(d-&gt;ptr, len, NUM2DBL(val));
      d-&gt;len = len;
   }
   /* we ensure that the vector is clean on exit of initialize */
   d-&gt;dirty = 0;
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-old_fancy_read" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">old_fancy_read</span><span
            class="method-args">(stream, cols = nil, opts = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>This function reads in <code>stream</code> (can an IO object or a String,
in which case it represents the name of a file to be opened) the columns
specified by <code>cols</code> and returns them. column 0 is the first
column. If <code>cols</code> is <code>nil</code>, then <a
href="Dvector.html#method-c-fancy_read">::fancy_read</a> attempts to find
all the columns in the file, while filling absent data with NaN.</p>

<p><code>opts</code> is a hash for tuning the behavior of the reading. It can
hold the following keys:</p>
<dl class="rdoc-list note-list"><dt>&#39;sep&#39;
<dd>
<p>the record separator</p>
</dd><dt>&#39;comments&#39;
<dd>
<p>a regular expression matching comment lines</p>
</dd><dt>&#39;skip_first&#39;
<dd>
<p>how many lines to skip at the beginning of the file,</p>
</dd><dt>&#39;default&#39;
<dd>
<p>the value taken for missing elements</p>
</dd><dt>&#39;index_col&#39;
<dd>
<p>if set to true, the first column contains the indices of the elements
(starting from 0 for first and so on)</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="old_fancy_read-source">
            <pre><span class="ruby-comment"># File lib/Dobjects/Dvector_extras.rb, line 137</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">old_fancy_read</span>(<span class="ruby-identifier">stream</span>, <span class="ruby-identifier">cols</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">opts</span> = {}) <span class="ruby-comment"># :doc:</span>
  <span class="ruby-comment"># first, we turn the stream into a real IO stream</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">stream</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">String</span>)
    <span class="ruby-identifier">stream</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">stream</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;&#39;stream&#39; should have a gets method&quot;</span>) <span class="ruby-keyword">unless</span> 
    <span class="ruby-identifier">stream</span>.<span class="ruby-identifier">respond_to?</span> <span class="ruby-value">:gets</span>
  
  <span class="ruby-comment"># we take default options and override them with opts</span>
  <span class="ruby-identifier">o</span> = <span class="ruby-constant">FANCY_READ_DEFAULTS</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>)
  
  <span class="ruby-comment"># strip off the first lines.</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">o</span>[<span class="ruby-string">&quot;skip_first&quot;</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">stream</span>.<span class="ruby-identifier">gets</span>
    <span class="ruby-identifier">o</span>[<span class="ruby-string">&quot;skip_first&quot;</span>] <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># then, parsing the lines. We store the results in an array. We read up</span>
  <span class="ruby-comment"># all columns, regardless of what is asked (it doesn&#39;t slow that much</span>
  <span class="ruby-comment"># the process -- or does it ?)</span>
  
  <span class="ruby-identifier">columns</span> = []
  <span class="ruby-identifier">line_number</span> = <span class="ruby-value">0</span> <span class="ruby-comment"># the number of the significant lines read so far</span>
  
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">line</span> = <span class="ruby-identifier">stream</span>.<span class="ruby-identifier">gets</span>
    <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">line</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">o</span>[<span class="ruby-string">&quot;comments&quot;</span>]
    <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">line</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/^\s*$/</span> <span class="ruby-comment"># skip empty lines</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">o</span>[<span class="ruby-string">&quot;remove_space&quot;</span>]
      <span class="ruby-identifier">line</span>.<span class="ruby-identifier">gsub!</span>(<span class="ruby-regexp">/^\s+/</span>,<span class="ruby-string">&#39;&#39;</span>)
    <span class="ruby-keyword">end</span>
  
    <span class="ruby-identifier">elements</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">split</span>(<span class="ruby-identifier">o</span>[<span class="ruby-string">&quot;sep&quot;</span>])
    <span class="ruby-comment"># now, the fun: the actual reading.</span>
    <span class="ruby-comment"># we first turn this elements into floats:</span>
    <span class="ruby-identifier">numbers</span> = <span class="ruby-identifier">elements</span>.<span class="ruby-identifier">collect</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> 
      <span class="ruby-keyword">begin</span> 
        <span class="ruby-identifier">a</span> = <span class="ruby-constant">Float</span>(<span class="ruby-identifier">s</span>)
      <span class="ruby-keyword">rescue</span>
        <span class="ruby-identifier">o</span>[<span class="ruby-string">&quot;default&quot;</span>]
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">numbers</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">columns</span>.<span class="ruby-identifier">size</span> 
      <span class="ruby-comment"># we pad it with default values</span>
      <span class="ruby-keyword">while</span> <span class="ruby-identifier">numbers</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">columns</span>.<span class="ruby-identifier">size</span>
        <span class="ruby-identifier">numbers</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">o</span>[<span class="ruby-string">&quot;default&quot;</span>]
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-comment"># in that case, we need to create new Dvectors to match the</span>
      <span class="ruby-comment"># size of numbers</span>
      <span class="ruby-keyword">while</span> <span class="ruby-identifier">columns</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">numbers</span>.<span class="ruby-identifier">size</span>
        <span class="ruby-identifier">columns</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">line_number</span>, <span class="ruby-identifier">o</span>[<span class="ruby-string">&quot;default&quot;</span>]) 
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-comment"># now, we should have the same number of elements both</span>
    <span class="ruby-comment"># in numbers and in columns</span>
    <span class="ruby-identifier">columns</span>.<span class="ruby-identifier">size</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">columns</span>[<span class="ruby-identifier">i</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">numbers</span>[<span class="ruby-identifier">i</span>]
    <span class="ruby-keyword">end</span>
    <span class="ruby-comment"># and it&#39;s done ;-) !</span>

    <span class="ruby-identifier">line_number</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment"># Adding the index columns if necessary</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">o</span>[<span class="ruby-string">&quot;index_col&quot;</span>] 
    <span class="ruby-identifier">columns</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">columns</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">length</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>})
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">columns</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">cols</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">cols</span>.<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> 
    <span class="ruby-identifier">columns</span>[<span class="ruby-identifier">i</span>]
  }
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-pm_cubic_interpolate" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            pm_cubic_interpolate(x, interpolant)  &rarr;  y
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the <em>y</em> corresponding to <em>x</em> by pm_cubic
interpolation using the <em>interpolant</em> which was previously created
by calling <em>create_pm_cubic_interpolant</em>.</p>
          
          

          
          <div class="method-source-code" id="pm_cubic_interpolate-source">
            <pre>VALUE dvector_pm_cubic_interpolate(int argc, VALUE *argv, VALUE klass) {
   if (argc != 2)
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d) for pm_cubic_interpolate&quot;, argc);
   klass = Qnil;
   VALUE x = argv[0];
   VALUE interpolant = argv[1];
   x = rb_Float(x);
   interpolant = rb_Array(interpolant);
   if (RARRAY_LEN(interpolant) != 5)
      rb_raise(rb_eArgError, &quot;interpolant must be array of length 5 from create_pm_cubic_interpolant&quot;);
   Dvector *Xs = Get_Dvector(rb_ary_entry(interpolant,0));
   Dvector *Ys = Get_Dvector(rb_ary_entry(interpolant,1));
   Dvector *As = Get_Dvector(rb_ary_entry(interpolant,2));
   Dvector *Bs = Get_Dvector(rb_ary_entry(interpolant,3));
   Dvector *Cs = Get_Dvector(rb_ary_entry(interpolant,4));
   if (Xs-&gt;len &lt;= 0 || Xs-&gt;len != Ys-&gt;len || Xs-&gt;len != Bs-&gt;len || Xs-&gt;len != Cs-&gt;len || Xs-&gt;len != As-&gt;len)
      rb_raise(rb_eArgError, &quot;interpolant must be from create_pm_cubic_interpolant&quot;);
   double y = c_dvector_pm_cubic_interpolate(NUM2DBL(x), Xs-&gt;len, Xs-&gt;ptr, Ys-&gt;ptr, As-&gt;ptr, Bs-&gt;ptr, Cs-&gt;ptr);
   return rb_float_new(y);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-read" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            read(filename, dest=nil, start=1, length=-1)  &rarr;  array of dvectors
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>The data on the file should be organized in columns of numbers, with one
row per line. The <em>start</em> parameter determines the starting line and
defaults to 1 meaning start at the first line of the file. The
<em>length</em> parameter determines the number of lines to be read and
defaults to -1 meaning read to the end of the file. Each column of data is
stored in a <a href="Dvector.html">Dvector</a>.  If the <em>dest</em>
argument is <code>nil</code>, the result array holds the newly created
vectors with the leftmost column in array entry 0, the second column in
entry 1, and so on. If <em>dest</em> is not <code>nil</code>, it must be an
array with entries either Dvectors or <code>nil</code>.  For entries that
are Dvectors, the contents of the vector are replaced by the column of data
from the file.  If the entry is <code>nil</code>, that column of the file
is skipped.</p>
          
          

          
          <div class="method-source-code" id="read-source">
            <pre>VALUE dvector_read(int argc, VALUE *argv, VALUE klass) {
   char *arg1 ;
   VALUE arg2 = Qnil;
   int arg3 = (int) 1 ;
   int arg4 = (int) -1 ;
   if ((argc &lt; 1) || (argc &gt; 4))
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d) for read&quot;, argc);
   arg1 = StringValueCStr(argv[0]);
   if (argc &gt; 1) arg2 = argv[1];
   if (argc &gt; 2) arg3 = NUM2INT(argv[2]);
   if (argc &gt; 3) arg4 = NUM2INT(argv[3]);
   return Read_Dvectors(arg1,arg2,arg3,arg4);
   klass = Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-read_columns" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            read(filename, dest=nil, start=1, length=-1)  &rarr;  array of dvectors
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>The data on the file should be organized in columns of numbers, with one
row per line. The <em>start</em> parameter determines the starting line and
defaults to 1 meaning start at the first line of the file. The
<em>length</em> parameter determines the number of lines to be read and
defaults to -1 meaning read to the end of the file. Each column of data is
stored in a <a href="Dvector.html">Dvector</a>.  If the <em>dest</em>
argument is <code>nil</code>, the result array holds the newly created
vectors with the leftmost column in array entry 0, the second column in
entry 1, and so on. If <em>dest</em> is not <code>nil</code>, it must be an
array with entries either Dvectors or <code>nil</code>.  For entries that
are Dvectors, the contents of the vector are replaced by the column of data
from the file.  If the entry is <code>nil</code>, that column of the file
is skipped.</p>
          
          

          
          <div class="method-source-code" id="read_columns-source">
            <pre>VALUE dvector_read(int argc, VALUE *argv, VALUE klass) {
   char *arg1 ;
   VALUE arg2 = Qnil;
   int arg3 = (int) 1 ;
   int arg4 = (int) -1 ;
   if ((argc &lt; 1) || (argc &gt; 4))
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d) for read&quot;, argc);
   arg1 = StringValueCStr(argv[0]);
   if (argc &gt; 1) arg2 = argv[1];
   if (argc &gt; 2) arg3 = NUM2INT(argv[2]);
   if (argc &gt; 3) arg4 = NUM2INT(argv[3]);
   return Read_Dvectors(arg1,arg2,arg3,arg4);
   klass = Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-read_row" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            read_row(filename, row=1, dvector=nil)  &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This routine reads a row of numbers from the named file. The <em>row</em>
argument determines which line of the file to read, starting at 1 for the
first line. If the <em>dvector</em> argument is <code>nil</code>, a new <a
href="Dvector.html">Dvector</a> is allocated to hold the row of numbers.
Otherwise, the contents of <em>dvector</em> are replaced by the numbers
from the line in the file.</p>
          
          

          
          <div class="method-source-code" id="read_row-source">
            <pre>VALUE dvector_read_row(int argc, VALUE *argv, VALUE klass) {
   char *arg1 ;
   int arg2 = (int) 1 ;
   VALUE arg3 = Qnil;
   if ((argc &lt; 1) || (argc &gt; 3))
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d) for read_row&quot;, argc);
   arg1 = StringValueCStr(argv[0]);
   if (argc &gt; 1) arg2 = NUM2INT(argv[1]);
   if (argc &gt; 2) arg3 = argv[2];
   return Read_Row(arg1,arg2,arg3);
   klass = Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-read_rows" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            read_rows(filename, dest, start=1)  &rarr;  array of dvectors
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>The data on the file should be organized in rows of numbers, with one row
per line. The rows need not all have the same number of entries since each
row is placed in its own <a href="Dvector.html">Dvector</a>. The
<em>start</em> parameter determines the starting line and defaults to 1
meaning start at the first line of the file. The <em>dest</em> must be an
array with entries either Dvectors or <code>nil</code>.  For entries that
are Dvectors, the contents of the vector are replaced by the row of data
from the file.  The <em>start</em> row is placed in the first entry in
<em>dest</em>, the second row in the next, and so on.  If the entry in
<em>dest</em> is <code>nil</code>, that row of the file is skipped.</p>
          
          

          
          <div class="method-source-code" id="read_rows-source">
            <pre>VALUE dvector_read_rows(int argc, VALUE *argv, VALUE klass) {
   int arg3 = (int) 1 ;
   if ((argc &lt; 2) || (argc &gt; 3))
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d) for read_rows&quot;, argc);
   if (argc &gt; 2) arg3 = NUM2INT(argv[2]);
   return Read_Rows_of_Dvectors(StringValueCStr(argv[0]),argv[1],arg3);
   klass = Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-spline_interpolate" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            spline_interpolate(x, interpolant)  &rarr;  y
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the <em>y</em> corresponding to <em>x</em> by spline interpolation
using the <em>interpolant</em> which was previously created by calling
<em>create_spline_interpolant</em>.</p>
          
          

          
          <div class="method-source-code" id="spline_interpolate-source">
            <pre>VALUE dvector_spline_interpolate(int argc, VALUE *argv, VALUE klass) {
   if (argc != 2)
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d) for spline_interpolate&quot;, argc);
   klass = Qnil;
   VALUE x = argv[0];
   VALUE interpolant = argv[1];
   x = rb_Float(x);
   interpolant = rb_Array(interpolant);
   if (RARRAY_LEN(interpolant) != 5)
      rb_raise(rb_eArgError, &quot;Spline interpolant must be array of length 5 from create_spline_interpolant&quot;);
   Dvector *Xs = Get_Dvector(rb_ary_entry(interpolant,0));
   Dvector *Ys = Get_Dvector(rb_ary_entry(interpolant,1));
   Dvector *As = Get_Dvector(rb_ary_entry(interpolant,2));
   Dvector *Bs = Get_Dvector(rb_ary_entry(interpolant,3));
   Dvector *Cs = Get_Dvector(rb_ary_entry(interpolant,4));
   if (Xs-&gt;len &lt;= 0 || Xs-&gt;len != Ys-&gt;len || Xs-&gt;len != Bs-&gt;len || Xs-&gt;len != Cs-&gt;len || Xs-&gt;len != As-&gt;len)
      rb_raise(rb_eArgError, &quot;Spline interpolant must be from create_spline_interpolant&quot;);
   double y = c_dvector_spline_interpolate(NUM2DBL(x), Xs-&gt;len, Xs-&gt;ptr, Ys-&gt;ptr, As-&gt;ptr, Bs-&gt;ptr, Cs-&gt;ptr);
   return rb_float_new(y);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-write" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">write</span><span
            class="method-args">(file, cols, options = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Writes an array of Dvectors into a text <em>file</em></p>
          
          

          
          <div class="method-source-code" id="write-source">
            <pre><span class="ruby-comment"># File lib/Dobjects/Dvector_extras.rb, line 280</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">write</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">cols</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-identifier">ops</span> = <span class="ruby-constant">WRITE_DEFAULTS</span>.<span class="ruby-identifier">update</span>(<span class="ruby-identifier">options</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">file</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">String</span>)
    <span class="ruby-identifier">file</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">ops</span>[<span class="ruby-string">&quot;write_mode&quot;</span>])
  <span class="ruby-keyword">end</span> 
  <span class="ruby-identifier">nb</span> = <span class="ruby-identifier">cols</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">d</span><span class="ruby-operator">|</span> <span class="ruby-identifier">d</span>.<span class="ruby-identifier">size</span>}.<span class="ruby-identifier">max</span> <span class="ruby-comment"># The number of lines</span>
  <span class="ruby-identifier">nb</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">file</span>.<span class="ruby-identifier">puts</span>(<span class="ruby-identifier">cols</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">d</span><span class="ruby-operator">|</span> <span class="ruby-identifier">d</span>[<span class="ruby-identifier">i</span>].<span class="ruby-identifier">to_s</span> }.<span class="ruby-identifier">join</span>(<span class="ruby-identifier">ops</span>[<span class="ruby-string">&quot;sep&quot;</span>]))
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-25" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">%</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-modulo">modulo</a>
        </div>
        
      </div>

    
      <div id="method-i-2A" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">*</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-mul">mul</a>
        </div>
        
      </div>

    
      <div id="method-i-2A-2A" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">**</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-pow">pow</a>
        </div>
        
      </div>

    
      <div id="method-i-2B" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">+</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-add">add</a>
        </div>
        
      </div>

    
      <div id="method-i-2D" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">-</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-sub">sub</a>
        </div>
        
      </div>

    
      <div id="method-i-2D-40" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">-@</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-neg">neg</a>
        </div>
        
      </div>

    
      <div id="method-i-2F" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">/</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-div">div</a>
        </div>
        
      </div>

    
      <div id="method-i-3C-3C" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector &lt;&lt; number  &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Append—Pushes the given number on to the end of this vector. This
expression returns the vector itself, so several appends may be chained
together.</p>

<pre>Dvector[ 1, 2 ] &lt;&lt; -3.3 &lt;&lt; 1e3    -&gt;  Dvector[ 1, 2, 3.3, 1000.0 ]</pre>
          
          

          
          <div class="method-source-code" id="3C-3C-source">
            <pre>VALUE dvector_push(VALUE ary, VALUE item) {
   item = rb_Float(item);
   Dvector_Push_Double(ary, NUM2DBL(item));
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3C-3D-3E" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector &lt;=&gt; other   &rarr;  -1, 0, +1
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Comparison—Returns an integer (-1, 0, or +1) if this vector is less than,
equal to, or greater than <em>other</em>.  Two vectors are “equal&#39;&#39;
according to <code>Dvector#&lt;=&gt;</code> if and only if they have the
same length and contain exactly the same values.</p>

<pre class="ruby"><span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span> ] <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ]        <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-value">-1</span>
<span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span> ] <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">3</span> ]        <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-value">+1</span>
<span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span> ] <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ]     <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-value">-1</span>
<span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span> ] <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span> ]  <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-value">+1</span>
</pre>
          
          

          
          <div class="method-source-code" id="3C-3D-3E-source">
            <pre>VALUE dvector_cmp(VALUE ary1, VALUE ary2) {
   long i, len;
   Dvector *d1, *d2;
   double *p1, *p2, v1, v2;
   d1 = Get_Dvector(ary1);
   d2 = Get_Dvector(ary2);
   len =d1-&gt;len;
   if (len &gt; d2-&gt;len) {
      len = d2-&gt;len;
   }
   p1 = d1-&gt;ptr; p2 = d2-&gt;ptr;
   for (i=0; i&lt;len; i++) {
      v1 = *p1++; v2 = *p2++;
      if (v1 &lt; v2) return INT2FIX(-1);
      if (v1 &gt; v2) return INT2FIX(1);
   }
   len = d1-&gt;len - d2-&gt;len;
   if (len == 0) return INT2FIX(0);
   if (len &gt; 0) return INT2FIX(1);
   return INT2FIX(-1);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3D-3D" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">==</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-eql-3F">eql?</a>
        </div>
        
      </div>

    
      <div id="method-i-5B-5D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector[int]                  &rarr; number or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector[start, length]        &rarr; dvector or nil
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector[range]                &rarr; dvector or nil
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            slice(index)          &rarr; number or nil
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            slice(start, length)  &rarr; dvector or nil
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            slice(range)          &rarr; dvector or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Element Reference—Returns the element at index <em>int</em>, or returns a
subvector starting at <em>start</em> and continuing for <em>length</em>
elements, or returns a subvector specified by <em>range</em>. Negative
indices count backward from the end of the vector (-1 is the last element).
Returns <code>nil</code> if the index (or starting index) are out of range.
If the start index equals the vector size and a <em>length</em> or
<em>range</em> parameter is given, an empty vector is returned.</p>

<pre>a = Dvector[ 1, 2, 3, 4, 5 ]
a[2] + a[0] + a[1]     -&gt; 6
a[6]                   -&gt; nil
a[1, 2]                -&gt; Dvector[ 2, 3 ]
a[1..3]                -&gt; Dvector[ 2, 3, 4 ]
a[4..7]                -&gt; Dvector[ 5 ]
a[6..10]               -&gt; nil
a[-3, 3]               -&gt; Dvector[ 3, 4, 5 ]
# special cases
a[5]                   -&gt; nil
a[5, 1]                -&gt; Dvector[]
a[5..10]               -&gt; Dvector[]</pre>
          
          

          
          <div class="method-source-code" id="5B-5D-source">
            <pre>VALUE dvector_aref(int argc, VALUE *argv, VALUE ary) {
   VALUE arg;
   long beg, len;
   Dvector *d = Get_Dvector(ary);
   if (argc == 2) {
      if (SYMBOL_P(argv[0])) {
         rb_raise(rb_eTypeError, &quot;Symbol as array index&quot;);
      }
      beg = NUM2LONG(argv[0]);
      len = NUM2LONG(argv[1]);
      if (beg &lt; 0) {
         beg += d-&gt;len;
      }
      return dvector_subseq(ary, beg, len);
   }
   if (argc != 1) {
      rb_scan_args(argc, argv, &quot;11&quot;, 0, 0);
   }
   arg = argv[0];
   /* special case - speeding up */
   if (FIXNUM_P(arg)) {
      return dvector_entry(ary, FIX2LONG(arg));
   }
   if (SYMBOL_P(arg)) {
      rb_raise(rb_eTypeError, &quot;Symbol as array index&quot;);
   }
   /* check if idx is Range */
   switch (rb_range_beg_len(arg, &amp;beg, &amp;len, d-&gt;len, 0)) {
      case Qfalse:
         break;
      case Qnil:
         return Qnil;
      default:
         return dvector_subseq(ary, beg, len);
   }
   return dvector_entry(ary, NUM2LONG(arg));
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-slice">slice</a>
        </div>
        

        
      </div>

    
      <div id="method-i-5B-5D-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector[int]           = number
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector[start, length] = number or a_dvector or an_array or nil
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector[range]         = number or a_dvector or an_array or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Element Assignment—Sets the element at index <em>int</em>, or replaces a
subvector starting at <em>start</em> and continuing for <em>length</em>
elements, or replaces a subvector specified by <em>range</em>.  Returns the
assigned object as value. If indices are greater than the current capacity
of the vector, the vector grows automatically by adding zeros. Negative
indices will count backward from the end of the vector. Inserts elements if
<em>length</em> is zero. If <code>nil</code> is used in the second and
third forms, deletes elements from <em>dvector</em>. A 1D Array of numbers
can be used on the right in the second and third forms in place of a <a
href="Dvector.html">Dvector</a>. An <code>IndexError</code> is raised if a
negative index points past the beginning of the vector. See also
<code>Dvector#push</code>, and <code>Dvector#unshift</code>.</p>

<pre>a = Dvector.new
a[4] = 4;                      -&gt; Dvector[ 0, 0, 0, 0, 4 ]
a[0, 3] = [ 1, 2, 3 ]          -&gt; Dvector[ 1, 2, 3, 0, 4 ]
a[1..2] = [ 1, 2 ]             -&gt; Dvector[ 1, 1, 2, 0, 4 ]
a[0, 2] = -1                   -&gt; Dvector[ -1, 2, 0, 4 ]
a[0..2] = 1                    -&gt; Dvector[ 1, 4 ]
a[-1]   = 5                    -&gt; Dvector[ 1, 5 ]
a[1..-1] = nil                 -&gt; Dvector[ 1 ]</pre>
          
          

          
          <div class="method-source-code" id="5B-5D-3D-source">
            <pre>VALUE dvector_aset(int argc, VALUE *argv, VALUE ary) {
   long offset, beg, len;
   Dvector *d = Get_Dvector(ary);
   VALUE arg1;
   if (argc == 3) {
      if (SYMBOL_P(argv[0])) {
         rb_raise(rb_eTypeError, &quot;Symbol as vector index&quot;);
      }
      if (SYMBOL_P(argv[1])) {
         rb_raise(rb_eTypeError, &quot;Symbol as subvector length&quot;);
      }
      dvector_splice(ary, NUM2LONG(argv[0]), NUM2LONG(argv[1]), argv[2]);
      return argv[2];
   }
   if (argc != 2) {
      rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 2)&quot;, argc);
   }
   if (FIXNUM_P(argv[0])) {
      offset = FIX2LONG(argv[0]);
      goto fixnum;
   }
   if (SYMBOL_P(argv[0])) {
      rb_raise(rb_eTypeError, &quot;Symbol as vector index&quot;);
   }
   if (rb_range_beg_len(argv[0], &amp;beg, &amp;len, d-&gt;len, 1)) {
      /* check if idx is Range */
      arg1 = argv[1];
      if (arg1 != Qnil &amp;&amp; !rb_obj_is_kind_of(arg1, rb_cNumeric) &amp;&amp; !is_a_dvector(arg1))
         arg1 = dvector_to_dvector(arg1);
      dvector_splice(ary, beg, len, arg1);
      return arg1;
   }
   offset = NUM2LONG(argv[0]);
  fixnum:
   dvector_store(ary, offset, argv[1]);
   return argv[1];
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-_dump" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">_dump</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Called by the marshalling mechanism to store a permanent copy of a  <a
href="Dvector.html">Dvector</a>. <em>limit</em> is simply ignored.</p>
          
          

          
          <div class="method-source-code" id="_dump-source">
            <pre>VALUE dvector_dump(VALUE ary, VALUE limit)
{
  int i; /* for STORE_UNSIGNED */
  long len;
  double * data = Dvector_Data_for_Read(ary, &amp;len);
  long target_len = 1 /* first signature byte */
    + 4 /* length */
    + len * 8 ;
  unsigned u_len = (unsigned) len; /* this is bad, I know, but it
                                      won&#39;t hurt before it is common
                                      that computers have 32 GB of RAM...
                                   */

  VALUE str = rb_str_new2(&quot;&quot;);
  rb_str_resize(str,target_len); /* This seems to do the trick */
  /* \begin{playing with ruby&#39;s internals} */
  unsigned char * ptr = (unsigned char *) RSTRING_PTR(str);
  /* signature byte */
  (*ptr++) = DVECTOR_DUMP_VERSION;
  STORE_UNSIGNED(u_len, ptr); /* destroys u_len */
  while(len-- &gt; 0)
    {
      store_double(*(data++), ptr);
      ptr += 8;
    }
  /*   RSTRING_LEN(str) = target_len; */
  return str;
  /* \end{playing with ruby&#39;s internals} */
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-abs" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            abs   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with all entries replaced by their
absolute values.</p>

<pre>a = Dvector[ 1, -2, -3, 4 ]
a.abs   -&gt; Dvector[ 1, 2, 3, 4 ]</pre>
          
          

          
          <div class="method-source-code" id="abs-source">
            <pre>VALUE dvector_abs(VALUE ary) {
   return dvector_apply_math_op(ary, fabs);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-abs-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            abs!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with abs(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.abs!   -&gt; Dvector[ 1.1, 2.2, 5.3 ]
a        -&gt; Dvector[ 1.1, 2.2, 5.3 ]</pre>
          
          

          
          <div class="method-source-code" id="abs-21-source">
            <pre>VALUE dvector_abs_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, fabs);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-acos" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            acos   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with entry x replaced by acos(x).</p>

<pre>a = Dvector[ 0.1, -0.2, -0.3, 0.4 ]
a.acos   -&gt; Dvector[ acos(0.1), acos(-0.2), acos(-0.3), acos(0.4) ]</pre>
          
          

          
          <div class="method-source-code" id="acos-source">
            <pre>VALUE dvector_acos(VALUE ary) {
   return dvector_apply_math_op(ary, acos);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-acos-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            acos!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with acos(x).</p>

<pre>a = Dvector[ 0.1, -0.2, 0.3 ]
a.acos!   -&gt; Dvector[ acos(0.1), acos(-0.2), acos(0.3) ]
a         -&gt; Dvector[ acos(0.1), acos(-0.2), acos(0.3) ]</pre>
          
          

          
          <div class="method-source-code" id="acos-21-source">
            <pre>VALUE dvector_acos_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, acos);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-acosh" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            acosh   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with entry x replaced by acosh(x).</p>

<pre>a = Dvector[ 5.1, 2.2, 1.3 ]
a.acosh   -&gt; Dvector[ acosh(5.1), acosh(2.2), acosh(1.3) ]</pre>
          
          

          
          <div class="method-source-code" id="acosh-source">
            <pre>VALUE dvector_acosh(VALUE ary) {
   return dvector_apply_math_op(ary, do_acosh);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-acosh-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            acosh!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with acosh(x).</p>

<pre>a = Dvector[ 1.1, 2.2, 5.3 ]
a.acosh!   -&gt; Dvector[ acosh(1.1), acosh(2.2), acosh(5.3) ]
a          -&gt; Dvector[ acosh(1.1), acosh(2.2), acosh(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="acosh-21-source">
            <pre>VALUE dvector_acosh_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, do_acosh);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-add" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            add(number)       &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            add(other)        &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector + number          &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            number + dvector          &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector + other           &rarr;  a_dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, this operation returns a copy of
<em>dvector</em> with each entry x replaced by x + <em>number</em>. When
argument is a vector, this operation returns a copy of <em>dvector</em>
with each entry x replaced by x + the corresponding entry in the
<em>other</em> vector.</p>

<pre>a = Dvector[ 11, -5, 2 ]
a.add(3)              -&gt; Dvector[ 14, -2, 5 ]
a + 3                 -&gt; Dvector[ 14, -2, 5 ]
3 + a                 -&gt; Dvector[ 14, -2, 5 ]
b = Dvector[ 7, 4, -10 ]
a.add(b)              -&gt; Dvector[ 18, -1, -8 ]
a + b                 -&gt; Dvector[ 18, -1, -8 ]</pre>
          
          

          
          <div class="method-source-code" id="add-source">
            <pre>VALUE dvector_add(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2(ary, arg, do_add);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-2B">+</a>, <a href="Dvector.html#method-i-plus">plus</a>
        </div>
        

        
      </div>

    
      <div id="method-i-add-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            add!(number)       &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            add!(other)        &rarr;  dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, each entry x in <em>dvector</em> is replaced by
x + <em>number</em>. When argument is a vector, each entry x in
<em>dvector</em> is replaced by x +  the corresponding entry in the
<em>other</em> vector.</p>

<pre>a = Dvector[ 11, -5, 2 ]
a.add!(3)              -&gt; Dvector[ 14, -2, 5 ]
a                      -&gt; Dvector[ 14, -2, 5 ]
a = Dvector[ 11, -5, 2 ]
b = Dvector[ 7, 4, -10 ]
a.add!(b)              -&gt; Dvector[ 18, -1, -8 ]
a                      -&gt; Dvector[ 18, -1, -8 ]</pre>
          
          

          
          <div class="method-source-code" id="add-21-source">
            <pre>VALUE dvector_add_bang(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2_bang(ary, arg, do_add);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-plus-21">plus!</a>
        </div>
        

        
      </div>

    
      <div id="method-i-as_exponent_of" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            as_exponent_of(number)                &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            as_exponent_of(other)                 &rarr;  a_dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, this operation returns a copy of
<em>dvector</em> with each entry x replaced by <em>number</em> ** x. When
argument is a vector, this operation returns a copy of <em>dvector</em>
with each entry x replaced by the corresponding entry in the <em>other</em>
vector raised to the power x.</p>

<pre>a = Dvector[ 2, -5, 12 ]
a.as_exponent_of(3.8)              -&gt; Dvector[ 3.8 ** 2, 3.8 ** (-5), 3.8 ** 12 ]
b = Dvector[ 7.1, 4.9, -10 ]
a.as_exponent_of(b)                -&gt; Dvector[ 7.1 ** 2, 4.9 ** (-5), (-10) ** 12 ]</pre>
          
          

          
          <div class="method-source-code" id="as_exponent_of-source">
            <pre>VALUE dvector_as_exponent_of(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2(ary, arg, do_as_exponent_of);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-as_exponent_of-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            as_exponent_of!(number)                &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            as_exponent_of!(other)                 &rarr;  dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, this operation replaces each entry x of
<em>dvector</em> by <em>number</em> ** x. When argument is a vector, this
operation replaces each entry x of <em>dvector</em> by the corresponding
entry in the <em>other</em> vector raised to the power x.</p>

<pre>a = Dvector[ 2, -5, 12 ]
a.as_exponent_of!(3.8)              -&gt; Dvector[ 3.8 ** 2, 3.8 ** (-5), 3.8 ** 12 ]
a                                   -&gt; Dvector[ 3.8 ** 2, 3.8 ** (-5), 3.8 ** 12 ]
b = Dvector[ 7.1, 4.9, -10 ]
a.as_exponent_of!(b)                -&gt; Dvector[ 7.1 ** 2, 4.9 ** (-5), (-10) ** 12 ]
a                                   -&gt; Dvector[ 7.1 ** 2, 4.9 ** (-5), (-10) ** 12 ]</pre>
          
          

          
          <div class="method-source-code" id="as_exponent_of-21-source">
            <pre>VALUE dvector_as_exponent_of_bang(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2_bang(ary, arg, do_as_exponent_of);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-asin" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            asin   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with entry x replaced by asin(x).</p>

<pre>a = Dvector[ 0.1, -0.2, -0.3, 0.4 ]
a.asin   -&gt; Dvector[ asin(0.1), asin(-0.2), asin(-0.3), asin(0.4) ]</pre>
          
          

          
          <div class="method-source-code" id="asin-source">
            <pre>VALUE dvector_asin(VALUE ary) {
   return dvector_apply_math_op(ary, asin);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-asin-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            asin!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with asin(x).</p>

<pre>a = Dvector[ 0.1, -0.2, 0.3 ]
a.asin!   -&gt; Dvector[ asin(0.1), asin(-0.2), asin(0.3) ]
a         -&gt; Dvector[ asin(0.1), asin(-0.2), asin(0.3) ]</pre>
          
          

          
          <div class="method-source-code" id="asin-21-source">
            <pre>VALUE dvector_asin_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, asin);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-asinh" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            asinh   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with entry x replaced by asinh(x).</p>

<pre>a = Dvector[ 0.1, -0.2, 0.3 ]
a.asinh   -&gt; Dvector[ asinh(0.1), asinh(-0.2), asinh(0.3) ]</pre>
          
          

          
          <div class="method-source-code" id="asinh-source">
            <pre>VALUE dvector_asinh(VALUE ary) {
   return dvector_apply_math_op(ary, do_asinh);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-asinh-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            asinh!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with asinh(x).</p>

<pre>a = Dvector[ 1.1, 2.2, 5.3 ]
a.asinh!   -&gt; Dvector[ asinh(1.1), asinh(2.2), asinh(5.3) ]
a          -&gt; Dvector[ asinh(1.1), asinh(2.2), asinh(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="asinh-21-source">
            <pre>VALUE dvector_asinh_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, do_asinh);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-at" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            at(int)  &rarr;  number or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the element at index <em>int</em>. A negative index counts from the
end of <em>dvector</em>.  Returns <code>nil</code> if the index is out of
range.</p>

<pre>a = Dvector[ 1, 2, 3, 4, 5 ]
a.at(0)     -&gt; 1
a.at(-1)    -&gt; 5</pre>
          
          

          
          <div class="method-source-code" id="at-source">
            <pre>VALUE dvector_at(VALUE ary, VALUE pos) {
   return dvector_entry(ary, NUM2LONG(pos));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-atan" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            atan   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with entry x replaced by atan(x).</p>

<pre>a = Dvector[ 0.1, -0.2, -0.3, 0.4 ]
a.atan   -&gt; Dvector[ atan(0.1), atan(-0.2), atan(-0.3), atan(0.4) ]</pre>
          
          

          
          <div class="method-source-code" id="atan-source">
            <pre>VALUE dvector_atan(VALUE ary) {
   return dvector_apply_math_op(ary, atan);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-atan-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            atan!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with atan(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.atan!   -&gt; Dvector[ atan(1.1), atan(-2.2), atan(5.3) ]
a         -&gt; Dvector[ atan(1.1), atan(-2.2), atan(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="atan-21-source">
            <pre>VALUE dvector_atan_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, atan);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-atan2" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            atan2(number)       &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            atan2(other)        &rarr;  a_dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, this operation returns a copy of
<em>dvector</em> with each entry x replaced by the angle whose tangent is
x/<em>number</em>. When argument is a vector, this operation returns a copy
of <em>dvector</em> with each entry x replaced by the angle whose tangent
is x divided by the corresponding entry in the <em>other</em> vector.</p>

<pre>a = Dvector[ 1.1, -5.7, 12.7 ]
a.atan2(3.8)              -&gt; Dvector[ atan2(1.1, 3.8), atan2(-5.7,3.8), atan2(12.7,3.8) ]
b = Dvector[ 7.1, 4.9, -10.1 ]
a.atan2(b)                -&gt; Dvector[ atan2(1.1,7.1), atan2(-5.7,4.9), atan2(12.7,-10.1) ]</pre>
          
          

          
          <div class="method-source-code" id="atan2-source">
            <pre>VALUE dvector_atan2(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2(ary, arg, atan2);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-atan2-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            atan2!(number)       &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            atan2!(other)        &rarr;  dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, this operation replaces each entry x of
<em>dvector</em> by the angle whose tangent is x/<em>number</em>. When
argument is a vector, this operation replaces each entry x of
<em>dvector</em> by the angle whose tangent is x divided by the
corresponding entry in the <em>other</em> vector.</p>

<pre>a = Dvector[ 1.1, -5.7, 12.7 ]
a.atan2!(3.8)              -&gt; Dvector[ atan2(1.1, 3.8), atan2(-5.7,3.8), atan2(12.7,3.8) ]
a = Dvector[ 1.1, -5.7, 12.7 ]
b = Dvector[ 7.1, 4.9, -10.1 ]
a.atan2!(b)                -&gt; Dvector[ atan2(1.1,7.1), atan2(-5.7,4.9), atan2(12.7,-10.1) ]</pre>
          
          

          
          <div class="method-source-code" id="atan2-21-source">
            <pre>VALUE dvector_atan2_bang(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2_bang(ary, arg, atan2);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-atanh" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            atanh   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with entry x replaced by atanh(x).</p>

<pre>a = Dvector[ 0.1, -0.2, 0.3 ]
a.atanh   -&gt; Dvector[ atanh(0.1), atanh(-0.2), atanh(0.3) ]</pre>
          
          

          
          <div class="method-source-code" id="atanh-source">
            <pre>VALUE dvector_atanh(VALUE ary) {
   return dvector_apply_math_op(ary, do_atanh);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-atanh-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            atanh!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with atanh(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.atanh!   -&gt; Dvector[ atanh(1.1), atanh(-2.2), atanh(5.3) ]
a          -&gt; Dvector[ atanh(1.1), atanh(-2.2), atanh(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="atanh-21-source">
            <pre>VALUE dvector_atanh_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, do_atanh);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-bounds" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">bounds</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns the boundaries of a <a href="Dvector.html">Dvector</a>, that is
[min, max]. It ignores NaN and will complain if the <a
href="Dvector.html">Dvector</a> contains only NaN.</p>

<pre>v = Dvector[0.0/0.0, 0.0/0.0, 1,2,4,5,9,0.0/0.0,0.1]
v.bounds -&gt; [0.1, 9]</pre>
          
          

          
          <div class="method-source-code" id="bounds-source">
            <pre>static VALUE dvector_bounds(VALUE self)
{
  double min, max;
  VALUE ret;
  long len;
  double * data = Dvector_Data_for_Read(self, &amp;len);
  /* skip all NaNs at the beginning */
  while(len-- &gt; 0)
    if(!isnan(*data++))
       break;
  if(len&gt;=0)
    {
      min = max = *(data-1);
      while(len-- &gt; 0)
        {
          if(! isnan(*data))
            {
              if(*data &lt; min)
                min = *data;
              if(*data &gt; max)
                max = *data;
            }
          data++;
        }
      ret = rb_ary_new2(2);
      rb_ary_store(ret, 0, rb_float_new(min));
      rb_ary_store(ret, 1, rb_float_new(max));
      return ret;
    }
  else
    rb_raise(rb_eRuntimeError, 
             &quot;bounds called on an array containing only NaN&quot;);
  return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ceil" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ceil   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with entry x replaced by smallest
integer not less than x.</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.ceil   -&gt; Dvector[ 2, -2, 6 ]</pre>
          
          

          
          <div class="method-source-code" id="ceil-source">
            <pre>VALUE dvector_ceil(VALUE ary) {
   return dvector_apply_math_op(ary, ceil);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ceil-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ceil!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with the smallest integer not less
than x.</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.ceil!   -&gt; Dvector[ 2, -2, 6 ]
a         -&gt; Dvector[ 2, -2, 6 ]</pre>
          
          

          
          <div class="method-source-code" id="ceil-21-source">
            <pre>VALUE dvector_ceil_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, ceil);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-clean-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            clean? &rarr; _true_ or _false_
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <em>true</em> if the vector hasn&#39;t been modified since the last
time dirty was cleared. See dirty?.</p>
          
          

          
          <div class="method-source-code" id="clean-3F-source">
            <pre>VALUE dvector_is_clean(VALUE ary) {
  if(RTEST(dvector_is_dirty(ary)))
    return Qfalse;
  return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-clear" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            clear  &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Removes all elements from <em>dvector</em>.</p>

<pre>a = Dvector[ 1, 2, 3, 4, 5 ]
a.clear    -&gt; Dvector[]</pre>
          
          

          
          <div class="method-source-code" id="clear-source">
            <pre>VALUE dvector_clear(VALUE ary) {
   Dvector *d = dvector_modify(ary);
   d-&gt;len = 0;
   if (DVEC_DEFAULT_SIZE * 2 &lt; d-&gt;capa) {
      REALLOC_N(d-&gt;ptr, double, DVEC_DEFAULT_SIZE * 2);
      d-&gt;capa = DVEC_DEFAULT_SIZE * 2;
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-collect" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            collect {|x| block }  &rarr; a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            map     {|x| block }  &rarr; a_dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Invokes <em>block</em> once for each element of <em>dvector</em>. Returns a
new vector holding the values returned by <em>block</em>. Note that for
numeric operations on long vectors, it is more efficient to apply the
operator directly to the vector rather than using map or collect.</p>

<pre class="ruby"> <span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span> ]
 <span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span> }      <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">2</span>, <span class="ruby-value">5</span>, <span class="ruby-value">10</span>, <span class="ruby-value">17</span> ]
<span class="ruby-constant">A</span> <span class="ruby-identifier">better</span> <span class="ruby-identifier">way</span><span class="ruby-operator">:</span>
 <span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span> ]
 <span class="ruby-identifier">a</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>                   <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">2</span>, <span class="ruby-value">5</span>, <span class="ruby-value">10</span>, <span class="ruby-value">17</span> ]
</pre>
          
          

          
          <div class="method-source-code" id="collect-source">
            <pre>VALUE dvector_collect(VALUE ary) {
   long i;
   VALUE collect;
   Dvector *d = Get_Dvector(ary);
   if (!rb_block_given_p()) {
      if ( is_a_dvector(ary) ) {
         return dvector_new4_dbl(d-&gt;len, d-&gt;ptr);
      }
      ary = rb_Array(ary);
      return dvector_new4(d-&gt;len, RARRAY_PTR(ary));
   }
   collect = dvector_new2(0,d-&gt;len);
   for (i = 0; i &lt; d-&gt;len; i++) {
      dvector_push(collect, rb_yield(rb_float_new(d-&gt;ptr[i])));
   }
   return collect;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-map">map</a>
        </div>
        

        
      </div>

    
      <div id="method-i-collect-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            collect! {|x| block }   &rarr;   dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            map!     {|x| block }   &rarr;   dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Invokes  <em>block</em> once for each element of <em>dvector</em>,
replacing the element with the value returned by <em>block</em>.</p>

<p>Note that for numeric operations on long vectors, it is more efficient to
apply the operator directly to the vector rather than using these
operators.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">2</span>, <span class="ruby-value">-3</span>, <span class="ruby-value">7</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span> }      <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">5</span>, <span class="ruby-value">10</span>, <span class="ruby-value">50</span> ]
<span class="ruby-identifier">a</span>                           <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">5</span>, <span class="ruby-value">10</span>, <span class="ruby-value">50</span> ]
</pre>

<p>A better way:</p>

<pre>a.mul!(a).add!(1)           -&gt; Dvector[ 5, 10, 50 ]</pre>
          
          

          
          <div class="method-source-code" id="collect-21-source">
            <pre>VALUE dvector_collect_bang(VALUE ary) {
   long i;
   Dvector *d= dvector_modify(ary);
   for (i = 0; i &lt; d-&gt;len; i++) {
      dvector_store(ary, i, rb_yield(rb_float_new(d-&gt;ptr[i])));
   }
   return ary;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-map-21">map!</a>
        </div>
        

        
      </div>

    
      <div id="method-i-collect2" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            collect2(other) {|x,y| block }  &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            map2(other)     {|x,y| block }  &rarr; dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calls <em>block</em> for each element of <em>dvector</em> along with the
corresponding element in <em>other</em>. Creates a  new vector containing
the values returned by <em>block</em>.  The vectors must be the same size.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">b</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map2</span>(<span class="ruby-identifier">b</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">y</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> }  <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">10</span>, <span class="ruby-value">16</span>, <span class="ruby-value">26</span> ]
</pre>
          
          

          
          <div class="method-source-code" id="collect2-source">
            <pre>VALUE dvector_collect2(VALUE ary, VALUE ary2) {
   long i;
   VALUE collect;
   Dvector *d = Get_Dvector(ary);
   Dvector *d2 = Get_Dvector(ary2);
   if (d-&gt;len != d2-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for collect2&quot;, d-&gt;len, d2-&gt;len);
   }
   if (!rb_block_given_p()) {
      return dvector_collect(ary);
   }
   collect = dvector_new2(0,d-&gt;len);
   for (i = 0; i &lt; d-&gt;len; i++) {
      dvector_push(collect, rb_yield_values(2, rb_float_new(d-&gt;ptr[i]), rb_float_new(d2-&gt;ptr[i])));
   }
   return collect;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-map2">map2</a>
        </div>
        

        
      </div>

    
      <div id="method-i-collect2-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            collect2! {|x,y| block }   &rarr;   dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            map2!     {|x,y| block }   &rarr;   dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Invokes <em>block</em> once for each element of <em>dvector</em>, replacing
the element with the value returned by <em>block</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">b</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map2!</span>(<span class="ruby-identifier">b</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">y</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> }  <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">10</span>, <span class="ruby-value">16</span>, <span class="ruby-value">26</span> ]
<span class="ruby-identifier">a</span>                                <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">10</span>, <span class="ruby-value">16</span>, <span class="ruby-value">26</span> ]
</pre>
          
          

          
          <div class="method-source-code" id="collect2-21-source">
            <pre>VALUE dvector_collect2_bang(VALUE ary, VALUE ary2) {
   long i;
   Dvector *d = dvector_modify(ary);
   Dvector *d2 = Get_Dvector(ary2);
   if (d-&gt;len != d2-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for collect2!&quot;, d-&gt;len, d2-&gt;len);
   }
   for (i = 0; i &lt; d-&gt;len; i++) {
      dvector_store(ary, i, rb_yield_values(2, rb_float_new(d-&gt;ptr[i]), rb_float_new(d2-&gt;ptr[i])));
   }
   return ary;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-map2-21">map2!</a>
        </div>
        

        
      </div>

    
      <div id="method-i-concat" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            concat(other)  &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Appends the elements in <em>other</em> to dvector.  <em>other</em>  can
either be a <a href="Dvector.html">Dvector</a> or a 1D Array of numbers.</p>

<p>a = Dvector[1, 5, -3] a.concat([6, 7])       -&gt; Dvector[ 1, 5, -3, 6, 7
]</p>

<p>a                      -&gt; Dvector[ 1, 5, -3, 6, 7 ]</p>
          
          

          
          <div class="method-source-code" id="concat-source">
            <pre>VALUE dvector_concat(VALUE x, VALUE y) {
   Dvector *c, *d;
   y = dvector_to_dvector(y);
   c = Get_Dvector(x);
   d = Get_Dvector(y);
   if (d-&gt;len &gt; 0) {
      dvector_splice(x, c-&gt;len, 0, y);
   }
   return x;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-convolve" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            convolve(kernel, middle)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>convolve applies a simple convolution to the vector using kernel centered
at the point middle. (0 is the leftmost point of the kernel).</p>
          
          

          
          <div class="method-source-code" id="convolve-source">
            <pre>static VALUE dvector_convolve(VALUE self, VALUE kernel, VALUE middle)
{
  long len;
  const double * values = Dvector_Data_for_Read(self, &amp;len);
  VALUE retval = dvector_new2(len,len);
  double * ret = Dvector_Data_for_Write(retval,NULL);
  long kernel_len;
  const double * ker = Dvector_Data_for_Read(kernel, &amp;kernel_len);
  /* I guess */
  long mid = NUM2LONG(middle);
  if(mid &gt; kernel_len)
    rb_raise(rb_eArgError, &quot;middle should be within kernel&#39;s range&quot;);
  else
    {
      long i,j,k;
      for(i = 0; i &lt; len; i++) 
        {
          double sum = 0, k_sum = 0;
          for(j = 0; j &lt; kernel_len; j++) 
            {
              /* check that we are within the vector */
              k = i - mid + j;         /* The current index inside the vector */
              /* This code is equivalent to saying that the vector is
                 prolongated until infinity with values at the boundaries
                 -&gt; no, obnoxious, I think. Simply don&#39;t take care
                 of these points
                 -&gt; yes, finally ?
              */
              if( k &lt; 0)
/*              continue; */
                k = 0;
              if( k &gt;= len)
/*              continue; */
                k = len - 1;
              sum += ker[j] * values[k];
              k_sum += ker[j];
            }
          sum/= k_sum;
          ret[i] = sum;
        }
    }
  return retval;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cos" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cos   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with entry x replaced by cos(x).</p>

<pre>a = Dvector[ 1, -2, -3, 4 ]
a.cos   -&gt; Dvector[ cos(1), cos(-2), cos(-3), cos(4) ]</pre>
          
          

          
          <div class="method-source-code" id="cos-source">
            <pre>VALUE dvector_cos(VALUE ary) {
   return dvector_apply_math_op(ary, cos);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cos-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cos!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with cos(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.cos!   -&gt; Dvector[ cos(1.1), cos(-2.2), cos(5.3) ]
a        -&gt; Dvector[ cos(1.1), cos(-2.2), cos(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="cos-21-source">
            <pre>VALUE dvector_cos_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, cos);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cosh" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cosh   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with entry x replaced by cosh(x).</p>

<pre>a = Dvector[ 0.1, -0.2, 0.3 ]
a.cosh   -&gt; Dvector[ cosh(0.1), cosh(-0.2), cosh(0.3) ]</pre>
          
          

          
          <div class="method-source-code" id="cosh-source">
            <pre>VALUE dvector_cosh(VALUE ary) {
   return dvector_apply_math_op(ary, cosh);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cosh-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cosh!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with cosh(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.cosh!   -&gt; Dvector[ cosh(1.1), cosh(-2.2), cosh(5.3) ]
a         -&gt; Dvector[ cosh(1.1), cosh(-2.2), cosh(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="cosh-21-source">
            <pre>VALUE dvector_cosh_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, cosh);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-delete" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            delete(number)            &rarr; number or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            delete(number) { block }  &rarr; number or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Deletes items from <em>dvector</em> that are equal to <em>number</em>. If
<em>number</em> is not found, returns <code>nil</code>. If the optional
code block is given, returns the result of <em>block</em> if the item is
not found.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">5</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-value">3</span> }
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">6</span>)                     <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-value">6</span>
<span class="ruby-identifier">a</span>                               <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[<span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">9</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">2</span>)                     <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">2</span>) { <span class="ruby-string">&quot;not found&quot;</span> }     <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;not found&quot;</span>
</pre>
          
          

          
          <div class="method-source-code" id="delete-source">
            <pre>VALUE dvector_delete(VALUE ary, VALUE item) {
   long len, i1, i2;
   Dvector *d;
   double val, e;
   item = rb_Float(item);
   val = NUM2DBL(item);
   d = dvector_modify(ary);
   len = d-&gt;len;
   for (i1 = i2 = 0; i1 &lt; d-&gt;len; i1++) {
      e = d-&gt;ptr[i1];
      if (e == val) continue;
      if (i1 != i2) {
         d-&gt;ptr[i2] = e;
      }
      i2++;
   }
   if (len == i2) {
      if (rb_block_given_p()) {
         return rb_yield(item);
      }
      return Qnil;
   }
   if (len &gt; i2) {
      d-&gt;len = i2;
      if (i2 * 2 &lt; d-&gt;capa &amp;&amp; d-&gt;capa &gt; DVEC_DEFAULT_SIZE) {
         REALLOC_N(d-&gt;ptr, double, i2 * 2);
         d-&gt;capa = i2 * 2;
      }
   }
   return item;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-delete_at" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            delete_at(int)  &rarr; number or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Deletes the element at the specified index <em>int</em>, returning that
element, or <code>nil</code> if the index is out of range.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">5</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-value">3</span> }
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">2</span>)                   <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-value">6</span>
<span class="ruby-identifier">a</span>                                <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[<span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">9</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">6</span>)                   <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>
</pre>
          
          

          
          <div class="method-source-code" id="delete_at-source">
            <pre>VALUE dvector_delete_at_m(VALUE ary, VALUE pos) {
    return dvector_delete_at(ary, NUM2LONG(pos));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-delete_if" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            delete_if {|x| block }  &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Deletes every element of <em>dvector</em> for which <em>block</em>
evaluates to <code>true</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">modulo</span>(<span class="ruby-value">2</span>) <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[<span class="ruby-value">1</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">a</span>                                     <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">3</span> ]
</pre>
          
          

          
          <div class="method-source-code" id="delete_if-source">
            <pre>VALUE dvector_delete_if(VALUE ary) {
   dvector_reject_bang(ary);
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dirty" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">dirty</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-dirty-3F">dirty?</a>
        </div>
        
      </div>

    
      <div id="method-i-dirty-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dirty= _true_ or _false_ &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sets (or unsets) the <em>dirty</em> flag. Returns <em>dvector</em>.</p>
          
          

          
          <div class="method-source-code" id="dirty-3D-source">
            <pre>VALUE dvector_set_dirty(VALUE ary, VALUE b) {
  Dvector *d;
  d = Get_Dvector(ary);
  d-&gt;dirty = RTEST(b);
  return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dirty-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dirty? &rarr; _true_ or _false_
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <em>true</em> if the vector has been modified since the last time
dirty was cleared. When a <a href="Dvector.html">Dvector</a> is created or
copied, dirty is set to false. It is set to true whenever the vector is
modified. You need to reset it manually using dirty=.</p>
          
          

          
          <div class="method-source-code" id="dirty-3F-source">
            <pre>VALUE dvector_is_dirty(VALUE ary) {
  Dvector *d;
  d = Get_Dvector(ary);
  if(d-&gt;dirty)
    return Qtrue;
  else
    return Qfalse;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-dirty">dirty</a>
        </div>
        

        
      </div>

    
      <div id="method-i-div" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            div(number)       &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            div(other)        &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector - number          &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            number - dvector          &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector - other           &rarr;  a_dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, this operation returns a copy of
<em>dvector</em> with each entry x replaced by x / <em>number</em>. When
argument is a vector, this operation returns a copy of <em>dvector</em>
with each entry x replaced by x / the corresponding entry in the
<em>other</em> vector.</p>

<pre>a = Dvector[ 1.1, -5.7, 2.5 ]
a.div(3.8)              -&gt; Dvector[ 1.1/3.8, -5.7/3.8, 2.5/3.8 ]
a / 3.8                 -&gt; Dvector[ 1.1/3.8, -5.7/3.8, 2.5/3.8 ]
3 / a                   -&gt; Dvector[ 3.8/1.1, -3.8/5.7, 3.8/2.5 ]
b = Dvector[ 7.1, 4.9, -10.1 ]
a.div(b)                -&gt; Dvector[ 1.1/7.1, -5.7/4.9, 2.5/10.1 ]
a / b                   -&gt; Dvector[ 1.1/7.1, -5.7/4.9, 2.5/10.1 ]</pre>
          
          

          
          <div class="method-source-code" id="div-source">
            <pre>VALUE dvector_div(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2(ary, arg, do_div);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-2F">/</a>
        </div>
        

        
      </div>

    
      <div id="method-i-div-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            div!(number)       &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            div!(other)        &rarr;  dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, each entry x in <em>dvector</em> is replaced by
x / <em>number</em>. When argument is a vector, each entry x in
<em>dvector</em> is replaced by x /  the corresponding entry in the
<em>other</em> vector.</p>

<pre>a = Dvector[ 1.1, -5.7, 2.5 ]
a.div!(3.8)             -&gt; Dvector[ 1.1/3.8, -5.7/3.8, 2.5/3.8 ]
a                       -&gt; Dvector[ 1.1/3.8, -5.7/3.8, 2.5/3.8 ]
a = Dvector[ 1.1, -5.7, 2.5 ]
b = Dvector[ 7.1, 4.9, -10.1 ]
a.div!(b)               -&gt; Dvector[ 1.1/7.1, -5.7/4.9, 2.5/10.1 ]
a                       -&gt; Dvector[ 1.1/7.1, -5.7/4.9, 2.5/10.1 ]</pre>
          
          

          
          <div class="method-source-code" id="div-21-source">
            <pre>VALUE dvector_div_bang(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2_bang(ary, arg, do_div);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dot" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dot(other)   &rarr;  number
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the sum of the products of entries in <em>dvector</em> and
<em>other</em>. Returns 0.0 if <em>dvector</em> is empty.  The vectors must
be the same length.</p>

<pre>a = Dvector[ 1, 2, 3, 4 ]
b = Dvector[ 1, -3, 3, 0 ]
a.dot(b)        -&gt; 4
Dvector[].dot(b)   -&gt; 0</pre>
          
          

          
          <div class="method-source-code" id="dot-source">
            <pre>VALUE dvector_dot(VALUE ary1, VALUE ary2) {
   Dvector *d1 = Get_Dvector(ary1), *d2 = Get_Dvector(ary2);
   double *p1 = d1-&gt;ptr, *p2 = d2-&gt;ptr, sum = 0.0;
   long len = d1-&gt;len, i;
   if (len != d2-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for dot&quot;, d1-&gt;len, d2-&gt;len);
   }
   for (i=0; i&lt;len; i++) sum += p1[i] * p2[i];
   return rb_float_new(sum);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dup" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dup  &rarr; a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a copy of <em>dvector</em>. For performance sensitive situations
involving a series of vector operations, first make a copy using dup and
then do “bang” operations to modify the result without further copying.</p>
          
          

          
          <div class="method-source-code" id="dup-source">
            <pre>VALUE dvector_dup(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   return dvector_new4_dbl(d-&gt;len, d-&gt;ptr);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each {|x| block }   &rarr;   dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calls <em>block</em> once for each element in <em>dvector</em>, passing
that element as a parameter.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">x</span>, <span class="ruby-string">&quot; -- &quot;</span> }
</pre>

<p>produces:</p>

<pre>1 -- 0 -- -1 --</pre>
          
          

          
          <div class="method-source-code" id="each-source">
            <pre>VALUE dvector_each(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   long i;
   for (i=0; i &lt; d-&gt;len; i++) {
      rb_yield(rb_float_new(d-&gt;ptr[i]));
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each2" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each2(other) {|x,y| block }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calls <em>block</em> once for each element in <em>dvector</em>, passing
that element as a parameter along with the corresponding element from the
<em>other</em> vector. The two vectors must be the same length.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">b</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each2</span>(<span class="ruby-identifier">b</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;(&quot;</span>, <span class="ruby-identifier">x</span> <span class="ruby-string">&quot;,&quot;</span>, <span class="ruby-identifier">y</span>, <span class="ruby-string">&quot;) &quot;</span> }
</pre>

<p>produces:</p>

<pre>(1,3) (0,4) (-1,5)</pre>
          
          

          
          <div class="method-source-code" id="each2-source">
            <pre>VALUE dvector_each2(VALUE ary, VALUE ary2) {
   Dvector *d = Get_Dvector(ary);
   Dvector *d2 = Get_Dvector(ary2);
   long i;
   if (d-&gt;len != d2-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for each2&quot;, d-&gt;len, d2-&gt;len);
   }
   for (i=0; i &lt; d-&gt;len; i++) {
      rb_yield_values(2, rb_float_new(d-&gt;ptr[i]), rb_float_new(d2-&gt;ptr[i]));
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each2_with_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each2_with_index(other) {|x,y,index| block }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calls <em>block</em> once for each element in <em>dvector</em>, passing the
element, the corresponding element from the <em>other</em> vector, and the
index.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">b</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each2_with_index</span>(<span class="ruby-identifier">b</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;(&quot;</span>, <span class="ruby-identifier">x</span> <span class="ruby-string">&quot;,&quot;</span>, <span class="ruby-identifier">y</span>, <span class="ruby-string">&quot;,&quot;</span>, <span class="ruby-identifier">i</span>, <span class="ruby-string">&quot;) &quot;</span> }
</pre>

<p>produces:</p>

<pre>(1,3,0) (0,4,1) (-1,5,2)</pre>
          
          

          
          <div class="method-source-code" id="each2_with_index-source">
            <pre>VALUE dvector_each2_with_index(VALUE ary, VALUE ary2) {
   Dvector *d = Get_Dvector(ary);
   Dvector *d2 = Get_Dvector(ary2);
   long i;
   if (d-&gt;len != d2-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for each2_with_index&quot;, d-&gt;len, d2-&gt;len);
   }
   for (i=0; i &lt; d-&gt;len; i++) {
      rb_yield_values(3, rb_float_new(d-&gt;ptr[i]), rb_float_new(d2-&gt;ptr[i]), LONG2NUM(i));
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each3" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each3(other1, other2) {|x,y, z| block }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calls <em>block</em> once for each element in <em>dvector</em>, passing
that element as a parameter along with the corresponding element from the
<em>other1</em> and <em>other2</em> vectors. The three vectors must be the
same length.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">b</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]
<span class="ruby-identifier">c</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">6</span>, <span class="ruby-value">9</span>, <span class="ruby-value">2</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each3</span>(<span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span>,<span class="ruby-identifier">z</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;(&quot;</span>, <span class="ruby-identifier">x</span> <span class="ruby-string">&quot;,&quot;</span>, <span class="ruby-identifier">y</span>, <span class="ruby-string">&quot;, &quot;</span>, <span class="ruby-identifier">z</span>, <span class="ruby-string">&quot;) &quot;</span> }
</pre>

<p>produces:</p>

<pre>(1,3,6) (0,4,9) (-1,5,2)</pre>
          
          

          
          <div class="method-source-code" id="each3-source">
            <pre>VALUE dvector_each3(VALUE ary, VALUE ary2, VALUE ary3) {
   Dvector *d = Get_Dvector(ary);
   Dvector *d2 = Get_Dvector(ary2);
   Dvector *d3 = Get_Dvector(ary3);
   long i;
   if (d-&gt;len != d2-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for each3&quot;, d-&gt;len, d2-&gt;len);
   }
   if (d-&gt;len != d3-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for each3&quot;, d-&gt;len, d3-&gt;len);
   }
   for (i=0; i &lt; d-&gt;len; i++) {
      rb_yield_values(3, rb_float_new(d-&gt;ptr[i]), rb_float_new(d2-&gt;ptr[i]), rb_float_new(d3-&gt;ptr[i]));
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each3_with_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each3_with_index(other1, other2) {|x,y,z,i| block }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calls <em>block</em> once for each element in <em>dvector</em>, passing
that element as a parameter along with the corresponding element from the
<em>other1</em> and <em>other2</em> vectors and the index. The three
vectors must be the same length.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">b</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]
<span class="ruby-identifier">c</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">6</span>, <span class="ruby-value">9</span>, <span class="ruby-value">2</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each3</span>(<span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span>,<span class="ruby-identifier">z</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;(&quot;</span>, <span class="ruby-identifier">x</span> <span class="ruby-string">&quot;,&quot;</span>, <span class="ruby-identifier">y</span>, <span class="ruby-string">&quot;, &quot;</span>, <span class="ruby-identifier">z</span>, <span class="ruby-string">&quot;,&quot;</span>, <span class="ruby-identifier">i</span>, <span class="ruby-string">&quot;) &quot;</span> }
</pre>

<p>produces:</p>

<pre>(1,3,6,0) (0,4,9,1) (-1,5,2,2)</pre>
          
          

          
          <div class="method-source-code" id="each3_with_index-source">
            <pre>VALUE dvector_each3_with_index(VALUE ary, VALUE ary2, VALUE ary3) {
   Dvector *d = Get_Dvector(ary);
   Dvector *d2 = Get_Dvector(ary2);
   Dvector *d3 = Get_Dvector(ary3);
   long i;
   if (d-&gt;len != d2-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for each3&quot;, d-&gt;len, d2-&gt;len);
   }
   if (d-&gt;len != d3-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for each3&quot;, d-&gt;len, d3-&gt;len);
   }
   for (i=0; i &lt; d-&gt;len; i++) {
      rb_yield_values(4, rb_float_new(d-&gt;ptr[i]), rb_float_new(d2-&gt;ptr[i]), rb_float_new(d3-&gt;ptr[i]), LONG2NUM(i));
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_index {|index| block }  &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Same as <code>Dvector#each</code>, but passes the index of the element
instead of the element itself.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">x</span>, <span class="ruby-string">&quot; -- &quot;</span> }
</pre>

<p>produces:</p>

<pre>0 -- 1 -- 2 --</pre>
          
          

          
          <div class="method-source-code" id="each_index-source">
            <pre>VALUE dvector_each_index(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   long i;
   for (i=0; i &lt; d-&gt;len; i++) {
      rb_yield(LONG2NUM(i));
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_with_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_with_index {|x,index| block }  &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Same as <code>Dvector#each</code>, but passes the index of the element in
addition to the element itself.</p>
          
          

          
          <div class="method-source-code" id="each_with_index-source">
            <pre>VALUE dvector_each_with_index(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   long i;
   for (i=0; i &lt; d-&gt;len; i++) {
      rb_yield_values(2, rb_float_new(d-&gt;ptr[i]), LONG2NUM(i));
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-empty-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            empty?   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if <em>dvector</em> vector contains no elements.</p>

<pre>Dvector[].empty?   -&gt; true</pre>
          
          

          
          <div class="method-source-code" id="empty-3F-source">
            <pre>VALUE dvector_empty_p(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   if (d-&gt;len == 0)
      return Qtrue;
   return Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-eql-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            eql?(other)  &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if <em>dvector</em> and <em>other</em> have the
same content.  <em>other</em>  can either be a <a
href="Dvector.html">Dvector</a> or a 1D Array of numbers.</p>
          
          

          
          <div class="method-source-code" id="eql-3F-source">
            <pre>VALUE dvector_eql(VALUE ary1, VALUE ary2) {
   long i, len;
   Dvector *d1, *d2;
   double *p1, *p2;
   if (ary1 == ary2) return Qtrue;
   if (ary1 == Qnil || ary2 == Qnil) return Qfalse;
   d1 = Get_Dvector(ary1);
   d2 = Get_Dvector(ary2);
   len = d1-&gt;len;
   if (len != d2-&gt;len) return Qfalse;
   p1 = d1-&gt;ptr; p2 = d2-&gt;ptr;
   for (i=0; i &lt; len; i++) {
      if (*p1++ != *p2++) return Qfalse;
   }
   return Qtrue;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-3D-3D">==</a>
        </div>
        

        
      </div>

    
      <div id="method-i-exp" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            exp   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with each entry x replaced by exp(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.exp   -&gt; Dvector[ exp(1.1), exp(-2.2), exp(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="exp-source">
            <pre>VALUE dvector_exp(VALUE ary) {
   return dvector_apply_math_op(ary, exp);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-exp-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            exp!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with exp(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.exp!   -&gt; Dvector[ exp(1.1), exp(-2.2), exp(5.3) ]
a        -&gt; Dvector[ exp(1.1), exp(-2.2), exp(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="exp-21-source">
            <pre>VALUE dvector_exp_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, exp);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-exp10" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            exp10   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with each entry x replaced by 10**x.</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.exp10   -&gt; Dvector[ 10**(1.1), 10**(-2.2), 10**(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="exp10-source">
            <pre>VALUE dvector_exp10(VALUE ary) {
   return dvector_apply_math_op(ary, do_exp10);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-exp10-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            exp10!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with 10**x.</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.exp10!   -&gt; Dvector[ 10**(1.1), 10**(-2.2), 10**(5.3) ]
a          -&gt; Dvector[ 10**(1.1), 10**(-2.2), 10**(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="exp10-21-source">
            <pre>VALUE dvector_exp10_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, do_exp10);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-extrema" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">extrema</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a list of local extrema of the vector, organized thus:</p>

<pre>[ [:min, idmin1], [:max, idmax1], ...]</pre>

<p>The values are pushed in the order in which they are found. It works thus:
it scans the vector and looks around the current point in a given window.
If the current point is the maximum or the minimum, it is considered as a
local maximum/minimum. Control over which extrema are included is given to
the used through threshold mechanisms.</p>

<p>The <em>options</em> hash controls how the peaks are detected:</p>

<pre>_window_: the number of elements on which we look on
both sides (default 5, ie the local maximum is over 11 points)
_threshold_: the minimum amplitude the extrema must have to
be considered (default 0)
_dthreshold_: how much over/under the average an extremum must be
(default 0) 
_or_: whether the _threshold_ and _dthreshold_ tests are both
necessary or if only one is (default false: both tests are
necessary)

 Note:* beware of NANs ! They *will* screw up peak detection, as</pre>

<p>they are neither bigger nor smaller than anything…</p>
          
          

          
          <div class="method-source-code" id="extrema-source">
            <pre>static VALUE dvector_extrema(int argc, VALUE *argv, VALUE self)
{
  long window = 5;
  double threshold = 0;
  double dthreshold = 0;
  int inclusive = 1;
  
  if(argc == 1) {
    VALUE t;
    t = rb_hash_aref(argv[0], rb_str_new2(&quot;window&quot;));
    if(RTEST(t)) {
      window = FIX2LONG(t);
    }
    t = rb_hash_aref(argv[0], rb_str_new2(&quot;threshold&quot;));
    if(RTEST(t)) {
      threshold = rb_num2dbl(t);
    }
    t = rb_hash_aref(argv[0], rb_str_new2(&quot;dthreshold&quot;));
    if(RTEST(t)) {
      dthreshold = rb_num2dbl(t);
    }
    
    t = rb_hash_aref(argv[0], rb_str_new2(&quot;or&quot;));
    inclusive = ! RTEST(t);
  } else if(argc &gt; 1)
    rb_raise(rb_eArgError, &quot;Dvector.extrema only takes 0 or 1 argument&quot;);

  /* Handling of the vector */
  long len, i,j;
  double * data = Dvector_Data_for_Read(self, &amp;len);
  VALUE s_min = ID2SYM(rb_intern(&quot;min&quot;));
  VALUE s_max = ID2SYM(rb_intern(&quot;max&quot;));

  

  VALUE ret = rb_ary_new();
                       
  for(i = 0; i &lt; len; i++) {

    /* This is stupid and will need decent optimization when I have
       time */
    long first = i &gt; window ? i - window : 0;
    double cur_min = data[first];
    long cur_min_idx = first;
    double cur_max = data[first];
    long cur_max_idx = first;
    double average = 0;
    long nb = 0;
    
    for(j = first; (j &lt; i+window) &amp;&amp; (j &lt; len); j++,nb++) {
      average += data[j];
      if(data[j] &lt;= cur_min) {
        cur_min = data[j];
        cur_min_idx = j;
      }
      if(data[j] &gt;= cur_max) {
        cur_max = data[j];
        cur_max_idx = j;
      }
    }
    average /= nb;

    if(cur_min_idx == i) {
      /* This is a potential minimum */
      if((inclusive &amp;&amp; 
          (fabs(cur_min) &gt;= threshold) &amp;&amp; 
          (fabs(cur_min - average) &gt;= dthreshold))
         || (!inclusive &amp;&amp; 
             ((fabs(cur_min) &gt;= threshold) ||
              (fabs(cur_min - average) &gt;= dthreshold))
             )) {
        VALUE min = rb_ary_new();
        rb_ary_push(min, s_min);
        rb_ary_push(min, LONG2FIX(i));
        rb_ary_push(ret, min);
      }
    }
    else if(cur_max_idx == i) {
      /* A potential maximum */
      if((inclusive &amp;&amp; 
          (fabs(cur_max) &gt;= threshold) &amp;&amp; 
          (fabs(cur_max - average) &gt;= dthreshold))
         || (!inclusive &amp;&amp; 
             ((fabs(cur_max) &gt;= threshold) ||
              (fabs(cur_max - average) &gt;= dthreshold))
             )) {
        VALUE max = rb_ary_new();
        rb_ary_push(max, s_max);
        rb_ary_push(max, LONG2FIX(i));
        rb_ary_push(ret, max);
      }
    }
  }
  return ret;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-fetch" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            fetch(int)                    &rarr; number
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            fetch(int, default )          &rarr; number
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            fetch(int) {|index| block }   &rarr; number
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Tries to return the element at index <em>int</em>. If the index lies
outside the vector, the first form throws an <code>IndexError</code>
exception, the second form returns <em>default</em>, and the third form
returns the value of invoking the block, passing in the index. Negative
values of the index count from the end of the vector.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">11</span>, <span class="ruby-value">22</span>, <span class="ruby-value">33</span>, <span class="ruby-value">44</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">1</span>)               <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-value">22</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">-1</span>)              <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-value">44</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">4</span>, <span class="ruby-value">0</span>)            <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">4</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span> }   <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-value">16</span>
</pre>
          
          

          
          <div class="method-source-code" id="fetch-source">
            <pre>VALUE dvector_fetch(int argc, VALUE *argv, VALUE ary) {
   VALUE pos, ifnone;
   long block_given;
   long idx;
   Dvector *d = Get_Dvector(ary);
   rb_scan_args(argc, argv, &quot;11&quot;, &amp;pos, &amp;ifnone);
   block_given = rb_block_given_p();
   if (block_given &amp;&amp; argc == 2) {
      rb_warn(&quot;block supersedes default value argument&quot;);
   }
   idx = NUM2LONG(pos);
   if (idx &lt; 0) {
      idx += d-&gt;len;
   }
   if (idx &lt; 0 || d-&gt;len &lt;= idx) {
      if (block_given) return rb_yield(pos);
      if (argc == 1) {
         rb_raise(rb_eIndexError, &quot;index %ld out of dvector&quot;, idx);
      }
      return ifnone;
   }
   return rb_float_new(d-&gt;ptr[idx]);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-fft-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">fft!</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Performs an in-place Fourier transform of the vector. The results is stored
in the so-called “half-complex” format (see <a
href="http://www.fftw.org/fftw3_doc/The-Halfcomplex_002dformat-DFT.html">www.fftw.org/fftw3_doc/The-Halfcomplex_002dformat-DFT.html</a>
for more information).</p>
          
          

          
          <div class="method-source-code" id="fft-21-source">
            <pre>static VALUE dvector_fft(VALUE self)
{
  long len;
  double * values = Dvector_Data_for_Write(self, &amp;len);
  fftw_plan plan = fftw_plan_r2r_1d(len, values, values,
                                    FFTW_R2HC, FFTW_ESTIMATE);
  fftw_execute(plan);
  fftw_destroy_plan(plan);
  return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-fft_conj-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">fft_conj!</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Converts the FFTed data in the complex conjugate</p>
          
          

          
          <div class="method-source-code" id="fft_conj-21-source">
            <pre>static VALUE dvector_fft_conj(VALUE self)
{
  long len;
  double * v1 = Dvector_Data_for_Write(self, &amp;len);
  double * img;
  long i;
  for(i = 1, img = v1 + len-1; i &lt; (len+1)/2;
      i++, img--)
    *img = -*img;
  return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-fft_mul-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">fft_mul!</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Multiplies the FFTed data held in the vector by another vector. The
behaviour depends on the size of the target vector:</p>

<pre>if it is the same size, it is assumed to be FFTed data
if it is the same size of a power spectrum, then it is assumed that it
is multiplication by real values
anything else won&#39;t make this function happy.</pre>

<p>As a side note, if you only want multiplication by a scalar, the standard
<a href="Dvector.html#method-i-mul-21">mul!</a> should be what you look
for.</p>
          
          

          
          <div class="method-source-code" id="fft_mul-21-source">
            <pre>static VALUE dvector_fft_mul(VALUE self, VALUE m)
{
  long len;
  double * v1 = Dvector_Data_for_Write(self, &amp;len);
  long len2;
  const double * v2 = Dvector_Data_for_Write(m, &amp;len2);
  if(len2 == len) {             /* Full complex multiplication */
    const double * m_img;
    const double * m_real;
    double * v_img;
    double * v_real;
    long i;
    /* First, special cases */
    v1[0] *= v2[0];
    if(len % 2 == 0)
      v1[len/2] *= v2[len/2];
    
    for(i = 1, m_real = v2 + 1, m_img = v2 + len-1,
          v_real = v1 + 1, v_img = v1 + len-1; i &lt; (len+1)/2;
        i++, m_real++, v_real++, m_img--, v_img--) {
      double r = *m_real * *v_real - *m_img * *v_img;
      *v_img = *m_real * *v_img + *v_real * *m_img;
      *v_real = r;
    }
    return self;
  }
  else if(len2 == len/2+1) {            /* Complex * real*/
    const double * val;
    double * v_img;
    double * v_real;
    long i;
    /* First, special cases */
    v1[0] *= v2[0];
    if(len % 2 == 0)
      v1[len/2] *= v2[len/2];
    
    for(i = 1, val = v2 + 1,
          v_real = v1 + 1, v_img = v1 + len-1; i &lt; (len+1)/2;
        i++, val++, v_real++, v_img--) {
      *v_real *= *val;
      *v_img *= *val;
    }
    return self;
  }
  else {
    rb_raise(rb_eArgError, &quot;incorrect Dvector size for fft_mul!&quot;);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-fft_spectrum" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">fft_spectrum</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns the power spectra of the ffted data (ie the square of the norm of
the complex fourier coefficients.</p>

<p>The returned value is a new <a href="Dvector.html">Dvector</a> of size
about two times smaller than the original (precisely size/2 + 1)</p>

<p>For some reasons, convolutions don&#39;t work for now.</p>
          
          

          
          <div class="method-source-code" id="fft_spectrum-source">
            <pre>static VALUE dvector_fft_spectrum(VALUE self)
{
  long len;
  const double * values = Dvector_Data_for_Read(self, &amp;len);
  /* First compute the size of the target: */
  long target_size = len/2+1;
  long i;
  VALUE retval = dvector_new2(target_size,target_size);
  double * ret = Dvector_Data_for_Write(retval,NULL);

  /* Pointer to real and imaginary parts */
  const double * real;
  const double * img;
  ret[0] = values[0] * values[0];


  /* The Nyquist frequency */
  if(len % 2 == 0)
    ret[target_size - 1] = values[target_size-1] * values[target_size-1];
  for(i = 1, real = values + 1, img = values + len-1; i &lt; len/2;
      i++, real++, img--)
    ret[i] = *real * *real + *img * *img;
  return retval;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-fill" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            fill(number)                             &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            fill(number, start &lt;, length&gt;)           &rarr; dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            fill(number, range )                     &rarr; dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            fill {|index| block }                    &rarr; dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            fill(start &lt;, length&gt; ) {|index| block } &rarr; dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            fill(range) {|index| block }             &rarr; dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>The first three forms set the selected elements of <em>dvector</em> (which
may be the entire vector) to <em>number</em>. A <em>start</em> of
<code>nil</code> is equivalent to zero. A <em>length</em> of
<code>nil</code> is equivalent to <em>dvector</em>.<code>length</code>. The
last three forms fill the vector with the value of the block. The block is
passed the absolute index of each element to be filled.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">-1</span>)               <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">-1</span>, <span class="ruby-value">-1</span>, <span class="ruby-value">-1</span>, <span class="ruby-value">-1</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">7</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>)          <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">-1</span>, <span class="ruby-value">-1</span>, <span class="ruby-value">7</span>, <span class="ruby-value">7</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">8</span>, <span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>)          <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">8</span>, <span class="ruby-value">8</span>, <span class="ruby-value">7</span>, <span class="ruby-value">7</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span>}         <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">4</span>, <span class="ruby-value">9</span>, <span class="ruby-value">16</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">-2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span>}   <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">4</span>, <span class="ruby-value">27</span>, <span class="ruby-value">64</span> ]
<span class="ruby-identifier">a</span>                        <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">4</span>, <span class="ruby-value">27</span>, <span class="ruby-value">64</span> ]
</pre>
          
          

          
          <div class="method-source-code" id="fill-source">
            <pre>VALUE dvector_fill(int argc, VALUE *argv, VALUE ary) {
   Dvector *d;
   VALUE item, arg1, arg2;
   long beg, end, len, i;
   double *p, *pend;
   int block_p = Qfalse;
   double v;
   d = dvector_modify(ary);
   if (rb_block_given_p()) {
      block_p = Qtrue;
      rb_scan_args(argc, argv, &quot;02&quot;, &amp;arg1, &amp;arg2);
      argc += 1;                /* hackish */
   } else {
      rb_scan_args(argc, argv, &quot;12&quot;, &amp;item, &amp;arg1, &amp;arg2);
   }
   switch (argc) {
      case 1:
         beg = 0;
         len = d-&gt;len;
         break;
      case 2:
         if (rb_range_beg_len(arg1, &amp;beg, &amp;len, d-&gt;len, 1)) {
            break;
         }
      /* fall through */
      case 3:
         beg = NIL_P(arg1) ? 0 : NUM2LONG(arg1);
         if (beg &lt; 0) {
            beg = d-&gt;len + beg;
            if (beg &lt; 0) beg = 0;
         }
         len = NIL_P(arg2) ? d-&gt;len - beg : NUM2LONG(arg2);
         break;
   }
   end = beg + len;
   if (end &gt; d-&gt;len) {
      if (end &gt;= d-&gt;capa) {
         REALLOC_N(d-&gt;ptr, double, end);
         d-&gt;capa = end;
      }
      if (beg &gt; d-&gt;len) {
         dvector_mem_clear(d-&gt;ptr + d-&gt;len, end - d-&gt;len);
      }
      d-&gt;len = end;
   }
   if (block_p) {
      for (i=beg; i&lt;end; i++) {
         item = rb_Float(rb_yield(LONG2NUM(i)));
         d-&gt;ptr[i] = NUM2DBL(item);
      }
   }
   else {
      p = d-&gt;ptr + beg;
      pend = p + len;
      item = rb_Float(item);
      v = NUM2DBL(item);
      while (p &lt; pend) {
         *p++ = v;
      }
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-first" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            first          &rarr;  number or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            first(count)   &rarr;  a_dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the first element, or the first <em>count</em> elements, of
<em>dvector</em>. If the vector is empty, the first form returns
<code>nil</code>, and the second returns an empty vector.</p>

<pre>a = Dvector[ 1, 2, 3, 4, 5 ]
a.first   -&gt; 1
a.first(1)   -&gt; Dvector[ 1 ]
a.first(3)   -&gt; Dvector[ 1, 2, 3 ]</pre>
          
          

          
          <div class="method-source-code" id="first-source">
            <pre>VALUE dvector_first(int argc, VALUE *argv, VALUE ary) {
   VALUE nv, result;
   long n, i;
   Dvector *d = Get_Dvector(ary);
   if (argc == 0) {
      if (d-&gt;len == 0) return Qnil;
      return rb_float_new(d-&gt;ptr[0]);
   }
   rb_scan_args(argc, argv, &quot;01&quot;, &amp;nv);
   n = NUM2LONG(nv);
   if (n &gt; d-&gt;len) n = d-&gt;len;
   result = dvector_new2(n,n);
   for (i=0; i&lt;n; i++) {
      Dvector_Store_Double(result, i, d-&gt;ptr[i]);
   }
   return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-floor" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            floor   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with each entry x replaced by largest
integer not greater than x.</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.floor   -&gt; Dvector[ 1, -3, 5 ]</pre>
          
          

          
          <div class="method-source-code" id="floor-source">
            <pre>VALUE dvector_floor(VALUE ary) {
   return dvector_apply_math_op(ary, floor);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-floor-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            floor!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with the largest integer not
greater than x.</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.floor!   -&gt; Dvector[ 1, -3, 5 ]
a          -&gt; Dvector[ 1, -3, 5 ]</pre>
          
          

          
          <div class="method-source-code" id="floor-21-source">
            <pre>VALUE dvector_floor_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, floor);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-freeze" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            freeze  &rarr; _dvector_
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Prevents further modifications.  A TypeError will be raised if modification
is attempted.</p>
          
          

          
          <div class="method-source-code" id="freeze-source">
            <pre>VALUE dvector_freeze(VALUE ary) {
   return rb_obj_freeze(ary);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-frozen-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            frozen?  &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Return <code>true</code> if this vector is frozen (or temporarily frozen
while being sorted).</p>
          
          

          
          <div class="method-source-code" id="frozen-3F-source">
            <pre>VALUE dvector_frozen_p(VALUE ary) {
   if (OBJ_FROZEN(ary)) return Qtrue;
   if (FL_TEST(ary, DVEC_TMPLOCK)) return Qtrue;
   return Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-include-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            include?(number)   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if <em>number</em> is present in
<em>dvector</em>, <code>false</code> otherwise.</p>

<pre>a = Dvector[ 1, 2, 3 ]
a.include?(2)   -&gt; true
a.include?(0)   -&gt; false</pre>
          
          

          
          <div class="method-source-code" id="include-3F-source">
            <pre>VALUE dvector_includes(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   long i, len = d-&gt;len;
   double x, *p = d-&gt;ptr;
   item = rb_Float(item);
   x = NUM2DBL(item);
   for (i=0; i &lt; len; i++) {
      if (*p++ == x) return Qtrue;
   }
   return Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            index(number)   &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the first object in <em>dvector</em></p>

<p><code>==</code> to <em>number</em>. Returns <code>nil</code> if no match is
found.</p>

<pre>a = Dvector[ 1, 2, 3, 4, 5, 4, 3, 2 ]
a.index(3)   -&gt; 2
a.index(0)   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="index-source">
            <pre>VALUE dvector_index(VALUE ary, VALUE val) {
   Dvector *d = Get_Dvector(ary);
   double v;
   long i = d-&gt;len;
   val = rb_Float(val);
   v = NUM2DBL(val);
   for (i=0; i &lt; d-&gt;len; i++) {
      if (d-&gt;ptr[i] == v)
         return LONG2NUM(i);
   }
   return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-initialize_copy" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            replace(other)  &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replaces the contents of <em>dvector</em> with the contents of
<em>other</em>, truncating or expanding if necessary.</p>

<pre>a = Dvector[ 1, 2, 3, 4, 5 ]
a.replace(Dvector[ -1, -2, -3 ])   -&gt; Dvector[ -1, -2, -3 ]
a                               -&gt; Dvector[ -1, -2, -3 ]</pre>
          
          

          
          <div class="method-source-code" id="initialize_copy-source">
            <pre>VALUE dvector_replace(VALUE dest, VALUE orig) {
   VALUE shared;
   Dvector *org, *d;
   dvector_modify(dest); // take care of any sharing issues.
   orig = dvector_to_dvector(orig); /* it might be some kind of Array rather than a Dvector */
   if (dest == orig) return dest;
   org = Get_Dvector(orig);
   d = Get_Dvector(dest);
   if (d-&gt;ptr) free(d-&gt;ptr); // we know it isn&#39;t shared because we did dvector_modify above
   shared = dvector_make_shared(orig);
   org = Get_Dvector(shared);
   d-&gt;ptr = org-&gt;ptr;
   d-&gt;len = org-&gt;len;
   d-&gt;shared = shared;
   return dest;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-insert" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            insert(int, number...)  &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>If the index is not negative, insert the given values before</p>

<pre> the element with the index _int_.  If the index is -1, appends the
 values to _dvector_.  Otherwise inserts the values after the element
with the given index.

 a = Dvector[ 1, 2, 3 ]
 a.insert(2, 99)         -&gt; Dvector[ 1, 2, 99, 3 ]
 a.insert(-2, 1, 2, 3)   -&gt; Dvector[ 1, 2, 99, 1, 2, 3, 3 ]
 a.insert(-1, 0)         -&gt; Dvector[ 1, 2, 99, 1, 2, 3, 3, 0 ]</pre>
          
          

          
          <div class="method-source-code" id="insert-source">
            <pre>VALUE dvector_insert(int argc, VALUE *argv, VALUE ary) {
   long pos;
   if (argc &lt; 1) {
      rb_raise(rb_eArgError, &quot;wrong number of arguments (at least 1)&quot;);
   }
   pos = NUM2LONG(argv[0]);
   if (pos == -1) {
      Dvector *d = Get_Dvector(ary);
      pos = d-&gt;len;
   }
   else if (pos &lt; 0) {
      pos++;
   }
   if (argc == 1) return ary;
   dvector_splice(ary, pos, 0, dvector_new4(argc - 1, argv + 1));
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inspect" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">inspect</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-to_s">to_s</a>
        </div>
        
      </div>

    
      <div id="method-i-inv" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            inv   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with each entry x replaced by 1/x.</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.inv   -&gt; Dvector[ 1 / 1.1, -1 / 2.2, 1 / 5.3 ]</pre>
          
          

          
          <div class="method-source-code" id="inv-source">
            <pre>VALUE dvector_inv(VALUE ary) {
   return dvector_apply_math_op(ary, do_inv);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inv-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            inv!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with 1/x.</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.inv!   -&gt; Dvector[ 1 / 1.1, -1 / 2.2, 1 / 5.3 ]
a        -&gt; Dvector[ 1 / 1.1, -1 / 2.2, 1 / 5.3 ]</pre>
          
          

          
          <div class="method-source-code" id="inv-21-source">
            <pre>VALUE dvector_inv_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, do_inv);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-join" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            join(sep=&quot; &quot;)    &rarr; a_string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a string created by converting each element of the vector to a
string, separated by <em>sep</em>.</p>

<pre>Dvector[ 1, 2, 3 ].join        -&gt; &quot;1 2 3&quot;
Dvector[ 1, 2, 3 ].join(&quot;-&quot;)   -&gt; &quot;1-2-3&quot;</pre>
          
          

          
          <div class="method-source-code" id="join-source">
            <pre>VALUE dvector_join_m(int argc, VALUE *argv, VALUE ary) {
   VALUE sep;
   rb_scan_args(argc, argv, &quot;01&quot;, &amp;sep);
   if (NIL_P(sep)) sep = dvector_output_fs;
   return dvector_join(ary, sep);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-last" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            last     &rarr;  number or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            last(count)  &rarr;  a_dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the last element, or the last <em>count</em> elements, of
<em>dvector</em>. If the vector is empty, the first form returns
<code>nil</code>, and the second returns an empty vector.</p>

<pre>a = Dvector[ 1, 2, 3, 4, 5 ]
a.last   -&gt; 5
a.last(1)   -&gt; Dvector[ 5 ]
a.last(3)   -&gt; Dvector[ 3, 4, 5 ]</pre>
          
          

          
          <div class="method-source-code" id="last-source">
            <pre>VALUE dvector_last(int argc, VALUE *argv, VALUE ary) {
   VALUE nv, result;
   long n, i, beg;
   Dvector *d = Get_Dvector(ary);
   if (argc == 0) {
      if (d-&gt;len == 0) return Qnil;
      return rb_float_new(d-&gt;ptr[d-&gt;len-1]);
   }
   rb_scan_args(argc, argv, &quot;01&quot;, &amp;nv);
   n = NUM2LONG(nv);
   if (n &gt; d-&gt;len) n = d-&gt;len;
   result = dvector_new2(n,n);
   beg = d-&gt;len - n;
   for (i=0; i &lt; n; i++) {
      Dvector_Store_Double(result, i, d-&gt;ptr[beg+i]);
   }
   return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-length" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            length &rarr; int
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the number of elements in <em>dvector</em>.</p>

<pre>Dvector[ 0, -1, 2, -3, 4 ].length   -&gt; 5
Dvector[].length                    -&gt; 0</pre>
          
          

          
          <div class="method-source-code" id="length-source">
            <pre>VALUE dvector_length(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   return LONG2NUM(d-&gt;len);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-size">size</a>, <a href="Dvector.html#method-i-nitems">nitems</a>
        </div>
        

        
      </div>

    
      <div id="method-i-log" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            log   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with each entry x replaced by log(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.log   -&gt; Dvector[ log(1.1), log(-2.2), log(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="log-source">
            <pre>VALUE dvector_log(VALUE ary) {
   return dvector_apply_math_op(ary, log);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-log-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            log!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with log(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.log!   -&gt; Dvector[ log(1.1), log(-2.2), log(5.3) ]
a        -&gt; Dvector[ log(1.1), log(-2.2), log(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="log-21-source">
            <pre>VALUE dvector_log_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, log);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-log10" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            log10   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with each entry x replaced by log10(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.log10   -&gt; Dvector[ log10(1.1), log10(-2.2), log10(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="log10-source">
            <pre>VALUE dvector_log10(VALUE ary) {
   return dvector_apply_math_op(ary, log10);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-log10-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            log10!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with log10(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.log10!   -&gt; Dvector[ log10(1.1), log10(-2.2), log10(5.3) ]
a          -&gt; Dvector[ log10(1.1), log10(-2.2), log10(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="log10-21-source">
            <pre>VALUE dvector_log10_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, log10);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-make_bezier_control_points_for_cubic_in_x" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            make_bezier_control_points_for_cubic_in_x(x0, y0, delta_x, a, b, c)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replaces contents of <em>dvector</em> by control points for Bezier curve.
The cubic, y(x), is defined from x0 to x0+delta_x. At location x = x0 + dx,
with dx between 0 and delta_x, define y = a*dx^3 + b*dx^2 + c*dx + y0. This
routine replaces the contents of <em>dest</em> by [x1, y1, x2, y2, x3, y3],
the Bezier control points to match this cubic.</p>
          
          

          
          <div class="method-source-code" id="make_bezier_control_points_for_cubic_in_x-source">
            <pre>VALUE dvector_make_bezier_control_points_for_cubic_in_x(VALUE dest, VALUE x0, VALUE y0, VALUE delta_x, VALUE a, VALUE b, VALUE c)
{
   x0 = rb_Float(x0);
   y0 = rb_Float(y0);
   delta_x = rb_Float(delta_x);
   a = rb_Float(a);
   b = rb_Float(b);
   c = rb_Float(c);
   return c_make_bezier_control_points_for_cubic_in_x(dest,
      NUM2DBL(x0), NUM2DBL(y0), NUM2DBL(delta_x), NUM2DBL(a), NUM2DBL(b), NUM2DBL(c));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-map" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">map</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-collect">collect</a>
        </div>
        
      </div>

    
      <div id="method-i-map-21" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">map!</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-collect-21">collect!</a>
        </div>
        
      </div>

    
      <div id="method-i-map2" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">map2</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-collect2">collect2</a>
        </div>
        
      </div>

    
      <div id="method-i-map2-21" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">map2!</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-collect2-21">collect2!</a>
        </div>
        
      </div>

    
      <div id="method-i-max" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            max   &rarr;  number or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            max(dvector2, ...)   &rarr;  number or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>First form returns the entry with the maximum value in <em>dvector</em>,
<code>nil</code> if <em>dvector</em> is empty.  Second form returns maximum
of all the vectors (or <code>nil</code> if all are empty).</p>

<pre>a = Dvector[ 1, 2, 3, 4, 5, 4, 3, 5, 2 ]
a.max               -&gt; 5
Dvector[].max          -&gt; nil
b = Dvector[ 8, 3, 0, 7 ]
a.max(b)            -&gt; 8</pre>
          
          

          
          <div class="method-source-code" id="max-source">
            <pre>VALUE dvector_max(int argc, VALUE *argv, VALUE self) {
   VALUE ary, index;
   int i, got_one = false;
   double mx=0, tmp;
   Dvector *d;
   for (i = 0; i &lt;= argc; i++) {
      ary = (i &lt; argc)? argv[i] : self;
      index = dvector_where_max(ary);
      if (index == Qnil) continue;
      d = Get_Dvector(ary);
      tmp = d-&gt;ptr[NUM2INT(index)];
      if (!got_one || tmp &gt; mx) { mx = tmp; got_one = true; }
   }
   if (!got_one) return Qnil;
   return rb_float_new(mx);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-max_lt" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            max_lt(val)  &rarr; float or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the maximum entry in <em>dvector</em> which is less than
<em>val</em>, or <code>nil</code> if no such entry if found.</p>
          
          

          
          <div class="method-source-code" id="max_lt-source">
            <pre>VALUE dvector_max_lt(VALUE ary, VALUE val) {
   Dvector *d = Get_Dvector(ary);
   val = rb_Float(val);
   double zmax = 0, z = NUM2DBL(val), x;
   double *data = d-&gt;ptr;
   int len = d-&gt;len, i, imax;
   imax = -1;
   for (i = 0; i &lt; len; i++) {
       x = data[i];
       if (x &lt; z &amp;&amp; (imax &lt; 0 || x &gt; zmax)) { imax = i; zmax = x; }
   }
   if (imax &gt;= 0)
      return rb_float_new(zmax);
   return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-min" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            min   &rarr;  number or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            min(dvector2, ...)   &rarr;  number or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>First form returns the entry with the minimum value in <em>dvector</em>,
<code>nil</code> if <em>dvector</em> is empty.  Second form returns minimum
of all the vectors (or <code>nil</code> if all are empty).</p>

<pre>a = Dvector[ 1, 2, 3, 4, 5, 4, 3, 5, 2 ]
a.min               -&gt; 1
Dvector[].min          -&gt; nil
b = Dvector[ 8, 3, 0, 7 ]
a.min(b)            -&gt; 0</pre>
          
          

          
          <div class="method-source-code" id="min-source">
            <pre>VALUE dvector_min(int argc, VALUE *argv, VALUE self) {
   VALUE ary, index;
   int i, got_one = false;
   double mn=0, tmp;
   Dvector *d;
   for (i = 0; i &lt;= argc; i++) {
      ary = (i &lt; argc)? argv[i] : self;
      index = dvector_where_min(ary);
      if (index == Qnil) continue;
      d = Get_Dvector(ary);
      tmp = d-&gt;ptr[NUM2INT(index)];
      if (!got_one || tmp &lt; mn) { mn = tmp; got_one = true; }
   }
   if (!got_one) return Qnil;
   return rb_float_new(mn);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-min_gt" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            min_gt(val)  &rarr; float or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the minimum entry in <em>dvector</em> which is greater than
<em>val</em>, or <code>nil</code> if no such entry if found.</p>
          
          

          
          <div class="method-source-code" id="min_gt-source">
            <pre>VALUE dvector_min_gt(VALUE ary, VALUE val) {
   Dvector *d = Get_Dvector(ary);
   val = rb_Float(val);
   double zmin = 0, z = NUM2DBL(val), x; /* it doesn&#39;t matter
                                            what is zmin&#39;s initial value 
                                         */
   double *data = d-&gt;ptr;
   int len = d-&gt;len, i, imin;
   imin = -1;
   for (i = 0; i &lt; len; i++) {
       x = data[i];
       if (x &gt; z &amp;&amp; (imin &lt; 0 || x &lt; zmin)) { imin = i; zmin = x; }
   }
   if (imin &gt;= 0)
      return rb_float_new(zmin);
   return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-minus" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">minus</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-sub">sub</a>
        </div>
        
      </div>

    
      <div id="method-i-minus-21" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">minus!</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-sub-21">sub!</a>
        </div>
        
      </div>

    
      <div id="method-i-mod" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">mod</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-modulo">modulo</a>
        </div>
        
      </div>

    
      <div id="method-i-mod-21" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">mod!</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-modulo-21">modulo!</a>
        </div>
        
      </div>

    
      <div id="method-i-modulo" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            modulo(number)       &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            mod(number)          &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            modulo(other)        &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            mod(other)           &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector % number             &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector % other              &rarr;  a_dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, this operation returns a copy of
<em>dvector</em> with each entry x replaced by x % <em>number</em>. When
argument is a vector, this operation returns a copy of <em>dvector</em>
with each entry x replaced by x % the corresponding entry in the
<em>other</em> vector.</p>

<pre>a = Dvector[ 1.1, -5.7, 12.7 ]
a.mod(3.8)              -&gt; Dvector[ 1.1, 1.9, 1.3 ]
a % 3.8                 -&gt; Dvector[ 1.1, 1.9, 1.3 ]
b = Dvector[ 7.1, 4.9, -10.1 ]
a.mod(b)                -&gt; Dvector[ 1.1, 4.1, -7.5 ]
a % b                   -&gt; Dvector[ 1.1, 4.1, -7.5 ]</pre>
          
          

          
          <div class="method-source-code" id="modulo-source">
            <pre>VALUE dvector_mod(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2(ary, arg, do_mod);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-mod">mod</a>, <a href="Dvector.html#method-i-25">%</a>
        </div>
        

        
      </div>

    
      <div id="method-i-modulo-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            modulo!(number)       &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            mod!(number)          &rarr;  dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            modulo!(other)        &rarr;  dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            mod!(other)           &rarr;  dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, this operation returns a copy of
<em>dvector</em> with each entry x replaced by x % <em>number</em>. When
argument is a vector, this operation returns a copy of <em>dvector</em>
with each entry x replaced by x % the corresponding entry in the
<em>other</em> vector.</p>

<pre>a = Dvector[ 1.1, -5.7, 12.7 ]
a.mod!(3.8)              -&gt; Dvector[ 1.1, 1.9, 1.3 ]
a                        -&gt; Dvector[ 1.1, 1.9, 1.3 ]
b = Dvector[ 7.1, 4.9, -10.1 ]
a.mod!(b)                -&gt; Dvector[ 1.1, 4.1, -7.5 ]
a                        -&gt; Dvector[ 1.1, 4.1, -7.5 ]</pre>
          
          

          
          <div class="method-source-code" id="modulo-21-source">
            <pre>VALUE dvector_modulo_bang(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2_bang(ary, arg, do_mod);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-mod-21">mod!</a>
        </div>
        

        
      </div>

    
      <div id="method-i-mul" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            mul(number)       &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            mul(other)        &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector - number          &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            number - dvector          &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector - other           &rarr;  a_dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, this operation returns a copy of
<em>dvector</em> with each entry x replaced by x * <em>number</em>. When
argument is a vector, this operation returns a copy of <em>dvector</em>
with each entry x replaced by x * the corresponding entry in the
<em>other</em> vector.</p>

<pre>a = Dvector[ 11, -5, 2 ]
a.mul(3)               -&gt; Dvector[ 33, -15, 6 ]
a * 3                  -&gt; Dvector[ 33, -15, 6 ]
3 * a                  -&gt; Dvector[ 33, -15, 6 ]
b = Dvector[ 7, 4, -10 ]
a.mul(b)               -&gt; Dvector[ 77, -20, -20 ]
a * b                  -&gt; Dvector[ 77, -20, -20 ]</pre>
          
          

          
          <div class="method-source-code" id="mul-source">
            <pre>VALUE dvector_mul(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2(ary, arg, do_mul);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-2A">*</a>, <a href="Dvector.html#method-i-times">times</a>
        </div>
        

        
      </div>

    
      <div id="method-i-mul-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            mul!(number)       &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            mul!(other)        &rarr;  dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, each entry x in <em>dvector</em> is replaced by
x * <em>number</em>. When argument is a vector, each entry x in
<em>dvector</em> is replaced by x *  the corresponding entry in the
<em>other</em> vector.</p>

<pre>a = Dvector[ 11, -5, 2 ]
a.mul!(3)               -&gt; Dvector[ 33, -15, 6 ]
a                       -&gt; Dvector[ 33, -15, 6 ]
a = Dvector[ 11, -5, 2 ]
b = Dvector[ 7, 4, -10 ]
a.mul!(b)               -&gt; Dvector[ 77, -20, -20 ]
a                       -&gt; Dvector[ 77, -20, -20 ]</pre>
          
          

          
          <div class="method-source-code" id="mul-21-source">
            <pre>VALUE dvector_mul_bang(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2_bang(ary, arg, do_mul);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-times-21">times!</a>
        </div>
        

        
      </div>

    
      <div id="method-i-neg" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            neg   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with each entry x replaced by -x.</p>

<pre>a = Dvector[ 1, 2, 3, 4 ]
a.neg   -&gt; Dvector[ -1, -2, -3, -4 ]</pre>
          
          

          
          <div class="method-source-code" id="neg-source">
            <pre>VALUE dvector_neg(VALUE ary) {
   return dvector_apply_math_op(ary, do_neg);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-2D-40">-@</a>
        </div>
        

        
      </div>

    
      <div id="method-i-neg-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            neg!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with -x.</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.neg!   -&gt; Dvector[ -1.1, 2.2, -5.3 ]
a        -&gt; Dvector[ -1.1, 2.2, -5.3 ]</pre>
          
          

          
          <div class="method-source-code" id="neg-21-source">
            <pre>VALUE dvector_neg_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, do_neg);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-nitems" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">nitems</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-length">length</a>
        </div>
        
      </div>

    
      <div id="method-i-plus" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">plus</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-add">add</a>
        </div>
        
      </div>

    
      <div id="method-i-plus-21" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">plus!</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-add-21">add!</a>
        </div>
        
      </div>

    
      <div id="method-i-pop" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            pop &rarr; number or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Removes the last element from <em>dvector</em> and returns it, or
<code>nil</code> if the vector is empty.</p>

<pre>a = Dvector[ 1, 2, 3 ]
a.pop   -&gt; 3
a       -&gt; Dvector[ 1, 2 ]</pre>
          
          

          
          <div class="method-source-code" id="pop-source">
            <pre>VALUE dvector_pop(VALUE ary) {
   Dvector *d = dvector_modify(ary);
   if (d-&gt;len == 0) return Qnil;
   if (d-&gt;shared == Qnil &amp;&amp; d-&gt;len * 2 &lt; d-&gt;capa &amp;&amp; d-&gt;capa &gt; DVEC_DEFAULT_SIZE) {
      d-&gt;capa = d-&gt;len * 2;
      REALLOC_N(d-&gt;ptr, double, d-&gt;capa);
   }
   return rb_float_new(d-&gt;ptr[--d-&gt;len]);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-pow" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            pow(number)                &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            pow(other)                 &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            raised_to(number)          &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            raised_to(other)           &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector ** number                  &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector ** other                   &rarr;  a_dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, this operation returns a copy of
<em>dvector</em> with each entry x replaced by x ** <em>number</em>. When
argument is a vector, this operation returns a copy of <em>dvector</em>
with each entry x replaced by x ** the corresponding entry in the
<em>other</em> vector.</p>

<pre>a = Dvector[ 1.1, -5.7, 12.7 ]
a.raised_to(3)              -&gt; Dvector[ 1.1 ** 3, (-5.7) ** 3, 12.7 ** 3 ]
a ** 3                      -&gt; Dvector[ 1.1 ** 3, (-5.7) ** 3, 12.7 ** 3 ]
b = Dvector[ 7, 4, -2 ]
a.raised_to(b)                -&gt; Dvector[ 1.1 ** 7, (-5.7) ** 4, 12.7 ** (-2) ]
a ** b                        -&gt; Dvector[ 1.1 ** 7, (-5.7) ** 4, 12.7 ** (-2) ]</pre>
          
          

          
          <div class="method-source-code" id="pow-source">
            <pre>VALUE dvector_pow(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2(ary, arg, pow);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-raised_to">raised_to</a>, <a href="Dvector.html#method-i-2A-2A">**</a>
        </div>
        

        
      </div>

    
      <div id="method-i-pow-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            pow!(number)                &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            pow!(other)                 &rarr;  dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            raised_to!(number)          &rarr;  dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            raised_to!(other)           &rarr;  dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, this operation returns a copy of
<em>dvector</em> with each entry x replaced by x ** <em>number</em>. When
argument is a vector, this operation returns a copy of <em>dvector</em>
with each entry x replaced by x ** the corresponding entry in the
<em>other</em> vector.</p>

<pre>a = Dvector[ 1.1, -5.7, 12.7 ]
a.raised_to!(3)                -&gt; Dvector[ 1.1 ** 3, (-5.7) ** 3, 12.7 ** 3 ]
a                              -&gt; Dvector[ 1.1 ** 3, (-5.7) ** 3, 12.7 ** 3 ]
b = Dvector[ 7, 4, -2 ]
a.raised_to!(b)                -&gt; Dvector[ 1.1 ** 7, (-5.7) ** 4, 12.7 ** (-2) ]
a                              -&gt; Dvector[ 1.1 ** 7, (-5.7) ** 4, 12.7 ** (-2) ]</pre>
          
          

          
          <div class="method-source-code" id="pow-21-source">
            <pre>VALUE dvector_pow_bang(VALUE ary, VALUE arg) {
   return dvector_apply_math_op1_bang(ary, arg, pow);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-raised_to-21">raised_to!</a>
        </div>
        

        
      </div>

    
      <div id="method-i-prune" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            prune(lst)  &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new dvector without the entries given by the indexes in
<em>lst</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">5</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-value">3</span> }    <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">6</span>, <span class="ruby-value">9</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">prune</span>([<span class="ruby-value">0</span>, <span class="ruby-value">2</span>])                  <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> [<span class="ruby-value">3</span>, <span class="ruby-value">9</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">a</span>                                <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">6</span>, <span class="ruby-value">9</span>, <span class="ruby-value">12</span>]
</pre>
          
          

          
          <div class="method-source-code" id="prune-source">
            <pre>VALUE dvector_prune(VALUE ary, VALUE lst) {
   ary = dvector_dup(ary);
   dvector_prune_bang(ary, lst);
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-prune-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            prune!(lst)  &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Modifies the dvector by removing the entries given by the indexes in
<em>lst</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">5</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-value">3</span> }    <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> [<span class="ruby-value">0</span>, <span class="ruby-value">3</span>, <span class="ruby-value">6</span>, <span class="ruby-value">9</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">prune!</span>([<span class="ruby-value">0</span>, <span class="ruby-value">2</span>])                 <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> [<span class="ruby-value">3</span>, <span class="ruby-value">9</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">a</span>                                <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> [<span class="ruby-value">3</span>, <span class="ruby-value">9</span>, <span class="ruby-value">12</span>]
</pre>
          
          

          
          <div class="method-source-code" id="prune-21-source">
            <pre>VALUE dvector_prune_bang(VALUE ary, VALUE lst) {
   Dvector *d;
   d = dvector_modify(ary);
   int i, lst_len, ary_len, pos, j;
   VALUE *lst_ptr;
   lst = rb_Array(lst);
   lst_ptr = RARRAY_PTR(lst);
   lst_len = RARRAY_LEN(lst);
   for (i = lst_len-1; i &gt;= 0; i--) {
      ary_len = d-&gt;len;
      pos = NUM2INT(lst_ptr[i]);  // remove this one from ary
      for (j = pos+1; j &lt; ary_len; j++, pos++) {
         d-&gt;ptr[pos] = d-&gt;ptr[j];
      }
      d-&gt;len = pos;
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-push" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            push(number, ... )  &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Append—Pushes the given number(s) on to the end of this vector.</p>

<pre>a = Dvector[ 1, 2, 3 ]
a.push(4, 5, 6)  -&gt; Dvector[1, 2, 3, 4, 5, 6]</pre>
          
          

          
          <div class="method-source-code" id="push-source">
            <pre>VALUE dvector_push_m(int argc, VALUE *argv, VALUE ary) {
   while (argc--) {
      dvector_push(ary, *argv++);
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-raised_to" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">raised_to</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-pow">pow</a>
        </div>
        
      </div>

    
      <div id="method-i-raised_to-21" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">raised_to!</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-pow-21">pow!</a>
        </div>
        
      </div>

    
      <div id="method-i-reject" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reject {|x| block }      &rarr; a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new vector containing the items in <em>dvector</em>, except those
for which the block is <code>true</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reject</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">modulo</span>(<span class="ruby-value">2</span>) <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[<span class="ruby-value">1</span>, <span class="ruby-value">3</span>]
</pre>
          
          

          
          <div class="method-source-code" id="reject-source">
            <pre>VALUE dvector_reject(VALUE ary) {
   ary = dvector_dup(ary);
   dvector_reject_bang(ary);
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reject-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reject! {|x| block }  &rarr; dvector or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Equivalent to <code>Dvector#delete_if</code>, deleting elements from
<em>dvector</em> for which the block evaluates to true, but returns
<code>nil</code> if no changes were made. Also see
<code>Enumerable#reject</code>.</p>
          
          

          
          <div class="method-source-code" id="reject-21-source">
            <pre>VALUE dvector_reject_bang(VALUE ary) {
   long i1, i2;
   Dvector *d;
   d = dvector_modify(ary);
   for (i1 = i2 = 0; i1 &lt; d-&gt;len; i1++) {
      double val = d-&gt;ptr[i1];
      VALUE v = rb_float_new(val);
      if (RTEST(rb_yield(v))) continue;
      if (i1 != i2) {
         d-&gt;ptr[i2] = val;
      }
      i2++;
   }
   if (d-&gt;len == i2) return Qnil;
   if (i2 &lt; d-&gt;len)
      d-&gt;len = i2;
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-remainder" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            remainder(number)          &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            remainder(other)           &rarr;  a_dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When the argument is a number, this operation returns a copy of
<em>dvector</em> with each entry x replaced by the remainder of x divided
by <em>number</em>. When the argument is a vector, this operation returns a
copy of <em>dvector</em> with each entry x replaced by the remainder of x
divided by the corresponding entry in the <em>other</em> vector.</p>

<pre>a = Dvector[ 11, -5, 2 ]
a.remainder(3)  -&gt; Dvector[ 2, -2, 2 ]
b = Dvector[ 2, 3, 5 ]
a.remainder(b)                -&gt; Dvector[ 1, -2, 2 ]</pre>
          
          

          
          <div class="method-source-code" id="remainder-source">
            <pre>VALUE dvector_remainder(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2(ary, arg, do_remainder);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-remainder-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            remainder!(number)          &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            remainder!(other)           &rarr;  dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When the argument is a number, this operation replaces with each entry x of
<em>dvector</em> by the remainder of x divided by <em>number</em>. When the
argument is a vector, this operation replaces with each entry x of
<em>dvector</em> by remainder of x divided by the corresponding entry in
the <em>other</em> vector.</p>

<pre>a = Dvector[ 11, -5, 2 ]
a.remainder!(3)                -&gt; Dvector[ 2, -2, 2 ]
a                              -&gt; Dvector[ 2, -2, 2 ]
a = Dvector[ 11, -5, 2 ]
b = Dvector[ 2, 3, 5 ]
a.remainder!(b)                -&gt; Dvector[ 1, -2, 2 ]
a                              -&gt; Dvector[ 1, -2, 2 ]</pre>
          
          

          
          <div class="method-source-code" id="remainder-21-source">
            <pre>VALUE dvector_remainder_bang(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2_bang(ary, arg, do_remainder);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-replace" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            replace(other)  &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replaces the contents of <em>dvector</em> with the contents of
<em>other</em>, truncating or expanding if necessary.</p>

<pre>a = Dvector[ 1, 2, 3, 4, 5 ]
a.replace(Dvector[ -1, -2, -3 ])   -&gt; Dvector[ -1, -2, -3 ]
a                               -&gt; Dvector[ -1, -2, -3 ]</pre>
          
          

          
          <div class="method-source-code" id="replace-source">
            <pre>VALUE dvector_replace(VALUE dest, VALUE orig) {
   VALUE shared;
   Dvector *org, *d;
   dvector_modify(dest); // take care of any sharing issues.
   orig = dvector_to_dvector(orig); /* it might be some kind of Array rather than a Dvector */
   if (dest == orig) return dest;
   org = Get_Dvector(orig);
   d = Get_Dvector(dest);
   if (d-&gt;ptr) free(d-&gt;ptr); // we know it isn&#39;t shared because we did dvector_modify above
   shared = dvector_make_shared(orig);
   org = Get_Dvector(shared);
   d-&gt;ptr = org-&gt;ptr;
   d-&gt;len = org-&gt;len;
   d-&gt;shared = shared;
   return dest;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-resize" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            resize(new_size)  &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Modifies <em>dvector</em> to have the requested size by truncating or
expanding with trailing zeros.</p>

<p>a = Dvector[1, 5, -3] a.resize(5)            -&gt; Dvector[ 1, 5, -3, 0, 0
]</p>

<p>a                      -&gt; Dvector[ 1, 5, -3, 0, 0 ]</p>

<p>a.resize(2)            -&gt; Dvector[ 1, 5 ]</p>

<p>a                      -&gt; Dvector[ 1, 5 ]</p>
          
          

          
          <div class="method-source-code" id="resize-source">
            <pre>VALUE dvector_resize(VALUE ary, VALUE len) {
   len = rb_Integer(len);
   long new_size = NUM2INT(len);
   return c_Resize(ary, new_size);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reverse" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reverse &rarr; a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new vector containing <em>dvector</em>&#39;s elements in reverse
order.</p>

<pre>Dvector[ 1, 2, 3 ].reverse         -&gt; Dvector[ 3, 2, 1 ]
Dvector[ 1 ].reverse               -&gt; Dvector[ 1 ]</pre>
          
          

          
          <div class="method-source-code" id="reverse-source">
            <pre>VALUE dvector_reverse_m(VALUE ary) {
   return dvector_reverse(dvector_dup(ary));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reverse-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reverse!   &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Reverses <em>dvector</em> in place.</p>

<pre>a = Dvector[ 1, 2, 3 ]
a.reverse!       -&gt; Dvector[ 3, 2, 1 ]
a                -&gt; Dvector[ 3, 2, 1 ]</pre>
          
          

          
          <div class="method-source-code" id="reverse-21-source">
            <pre>VALUE dvector_reverse_bang(VALUE ary) {
   return dvector_reverse(ary);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reverse_each" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reverse_each {|x| block }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Same as <code>Dvector#each</code>, but traverses <em>dvector</em> in
reverse order.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">x</span>, <span class="ruby-string">&quot; &quot;</span> }
</pre>

<p>produces:</p>

<pre>-1 0 1</pre>
          
          

          
          <div class="method-source-code" id="reverse_each-source">
            <pre>VALUE dvector_reverse_each(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   long len = d-&gt;len;
   while (len--) {
      rb_yield(rb_float_new(d-&gt;ptr[len]));
      if (d-&gt;len &lt; len) {
         len = d-&gt;len;
      }
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reverse_each2" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reverse_each2(other) {|x,y| block }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Same as <code>Dvector#each2</code>, but traverses vectors in reverse order.
The vectors must have the same size.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">b</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse_each2</span>(<span class="ruby-identifier">b</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;(&quot;</span>, <span class="ruby-identifier">x</span> <span class="ruby-string">&quot;,&quot;</span>, <span class="ruby-identifier">y</span>, <span class="ruby-string">&quot;) &quot;</span> }
</pre>

<p>produces:</p>

<pre>(-1,5) (0,4) (1,3)</pre>
          
          

          
          <div class="method-source-code" id="reverse_each2-source">
            <pre>VALUE dvector_reverse_each2(VALUE ary, VALUE ary2) {
   Dvector *d = Get_Dvector(ary);
   Dvector *d2 = Get_Dvector(ary2);
   long len = d-&gt;len;
   if (len != d2-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for reverse_each2&quot;, len, d2-&gt;len);
   }
   while (len--) {
      rb_yield_values(2, rb_float_new(d-&gt;ptr[len]), rb_float_new(d2-&gt;ptr[len]));
      if (d-&gt;len &lt; len) {
         len = d-&gt;len;
      }
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reverse_each2_with_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reverse_each2_with_index {|x,y,index| block }  &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Same as <code>Dvector#each2_with_index</code>, but traverses the vectors in
reverse order.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">b</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse_each2_with_index</span>(<span class="ruby-identifier">b</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;(&quot;</span>, <span class="ruby-identifier">x</span> <span class="ruby-string">&quot;,&quot;</span>, <span class="ruby-identifier">y</span>, <span class="ruby-string">&quot;,&quot;</span> <span class="ruby-identifier">i</span>, <span class="ruby-string">&quot;) &quot;</span> }
</pre>

<p>produces:</p>

<pre>(-1,5,2) (0,4,1) (1,3,0)</pre>
          
          

          
          <div class="method-source-code" id="reverse_each2_with_index-source">
            <pre>VALUE dvector_reverse_each2_with_index(VALUE ary, VALUE ary2) {
   Dvector *d = Get_Dvector(ary);
   Dvector *d2 = Get_Dvector(ary2);
   long len = d-&gt;len;
   if (len != d2-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for reverse_each2_with_index&quot;, 
         len, d2-&gt;len);
   }
   while (len--) {
      rb_yield_values(3, rb_float_new(d-&gt;ptr[len]), rb_float_new(d2-&gt;ptr[len]), LONG2NUM(len));
      if (d-&gt;len &lt; len) {
         len = d-&gt;len;
      }
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reverse_each3" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reverse_each3(other1, other2) {|x,y,z| block }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Same as <code>Dvector#each3</code>, but traverses vectors in reverse order.
The vectors must have the same size.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">b</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]
<span class="ruby-identifier">c</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">6</span>, <span class="ruby-value">9</span>, <span class="ruby-value">2</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse_each3</span>(<span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span>,<span class="ruby-identifier">z</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;(&quot;</span>, <span class="ruby-identifier">x</span> <span class="ruby-string">&quot;,&quot;</span>, <span class="ruby-identifier">y</span>, <span class="ruby-string">&quot;, &quot;</span>, <span class="ruby-identifier">z</span>, <span class="ruby-string">&quot;) &quot;</span> }
</pre>

<p>produces:</p>

<pre>(-1,5,2) (0,4,9) (1,3,6)</pre>
          
          

          
          <div class="method-source-code" id="reverse_each3-source">
            <pre>VALUE dvector_reverse_each3(VALUE ary, VALUE ary2, VALUE ary3) {
   Dvector *d = Get_Dvector(ary);
   Dvector *d2 = Get_Dvector(ary2);
   Dvector *d3 = Get_Dvector(ary3);
   long len = d-&gt;len;
   if (len != d2-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for reverse_each3&quot;, len, d2-&gt;len);
   }
   if (len != d3-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for reverse_each3&quot;, len, d3-&gt;len);
   }
   while (len--) {
      rb_yield_values(3, rb_float_new(d-&gt;ptr[len]), rb_float_new(d2-&gt;ptr[len]), rb_float_new(d3-&gt;ptr[len]));
      if (d-&gt;len &lt; len) {
         len = d-&gt;len;
      }
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reverse_each3_with_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reverse_each3_with_index {|x,y,z,index| block }  &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Same as <code>Dvector#each3_with_index</code>, but traverses the vectors in
reverse order.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">b</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]
<span class="ruby-identifier">c</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">6</span>, <span class="ruby-value">9</span>, <span class="ruby-value">2</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse_each3_with_index</span>(<span class="ruby-identifier">b</span>,<span class="ruby-identifier">c</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;(&quot;</span>, <span class="ruby-identifier">x</span> <span class="ruby-string">&quot;,&quot;</span>, <span class="ruby-identifier">y</span>, <span class="ruby-string">&quot;,&quot;</span> <span class="ruby-identifier">i</span>, <span class="ruby-string">&quot;) &quot;</span> }
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each3</span>(<span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span>,<span class="ruby-identifier">z</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;(&quot;</span>, <span class="ruby-identifier">x</span> <span class="ruby-string">&quot;,&quot;</span>, <span class="ruby-identifier">y</span>, <span class="ruby-string">&quot;, &quot;</span>, <span class="ruby-identifier">z</span>, <span class="ruby-string">&quot;,&quot;</span>, <span class="ruby-identifier">i</span>, <span class="ruby-string">&quot;) &quot;</span> }
</pre>

<p>produces:</p>

<pre>(-1,5,2,2) (0,4,9,1) (1,3,6,0)</pre>
          
          

          
          <div class="method-source-code" id="reverse_each3_with_index-source">
            <pre>VALUE dvector_reverse_each3_with_index(VALUE ary, VALUE ary2, VALUE ary3) {
   Dvector *d = Get_Dvector(ary);
   Dvector *d2 = Get_Dvector(ary2);
   Dvector *d3 = Get_Dvector(ary3);
   long len = d-&gt;len;
   if (len != d2-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for reverse_each3_with_index&quot;, 
         len, d3-&gt;len);
   }
   if (len != d3-&gt;len) {
      rb_raise(rb_eArgError, &quot;vectors with different lengths (%ld vs %ld) for reverse_each3_with_index&quot;, 
         len, d3-&gt;len);
   }
   while (len--) {
      rb_yield_values(4, rb_float_new(d-&gt;ptr[len]), rb_float_new(d2-&gt;ptr[len]), rb_float_new(d3-&gt;ptr[len]), LONG2NUM(len));
      if (d-&gt;len &lt; len) {
         len = d-&gt;len;
      }
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reverse_each_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reverse_each_index {|index| block }  &rarr;  array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Same as <code>Dvector#reverse_each</code>, but passes the index of the
element instead of the element itself.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse_each_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">i</span>, <span class="ruby-string">&quot; -- &quot;</span> }
</pre>

<p>produces:</p>

<pre>2 -- 1 -- 0 --</pre>
          
          

          
          <div class="method-source-code" id="reverse_each_index-source">
            <pre>VALUE dvector_reverse_each_index(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   long len = d-&gt;len;
   while (len--) {
      rb_yield(LONG2NUM(len));
      if (d-&gt;len &lt; len) {
         len = d-&gt;len;
      }
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reverse_each_with_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reverse_each_with_index {|x,index| block }  &rarr;  array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Same as <code>Dvector#each_with_index</code>, but traverses
<em>dvector</em> in reverse order.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-value">-1</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse_each_with_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;(&quot;</span>, <span class="ruby-identifier">x</span>, <span class="ruby-string">&quot;,&quot;</span>, <span class="ruby-identifier">i</span>, <span class="ruby-string">&quot;) &quot;</span> }
</pre>

<p>produces:</p>

<pre>(-1,2) (0,1) (1,0)</pre>
          
          

          
          <div class="method-source-code" id="reverse_each_with_index-source">
            <pre>VALUE dvector_reverse_each_with_index(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   long len = d-&gt;len;
   while (len--) {
      rb_yield_values(2, rb_float_new(d-&gt;ptr[len]), LONG2NUM(len));
      if (d-&gt;len &lt; len) {
         len = d-&gt;len;
      }
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-rfft-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">rfft!</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Performs a reverse in-place Fourier transform of the vector. The original
data must have been stored in the so called “half-complex” format (see <a
href="Dvector.html#method-i-fft-21">fft!</a>).</p>
          
          

          
          <div class="method-source-code" id="rfft-21-source">
            <pre>static VALUE dvector_rfft(VALUE self)
{
  long len;
  double * values = Dvector_Data_for_Write(self, &amp;len);
  fftw_plan plan = fftw_plan_r2r_1d(len, values, values,
                                    FFTW_HC2R, FFTW_ESTIMATE);
  fftw_execute(plan);
  fftw_destroy_plan(plan);
  return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-rindex" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            rindex(number)    &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the last object in <em>dvector</em>  <code>==</code>
to <em>number</em>. Returns <code>nil</code> if no match is found.</p>

<pre>a = Dvector[ 1, 2, 3, 4, 5, 4, 3, 2 ]
a.rindex(3)   -&gt; 6
a.rindex(0)   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="rindex-source">
            <pre>VALUE dvector_rindex(VALUE ary, VALUE val) {
   Dvector *d = Get_Dvector(ary);
   double v;
   long i = d-&gt;len;
   val = rb_Float(val);
   v = NUM2DBL(val);
   while (i--) {
      if (i &gt; d-&gt;len) {
         i = d-&gt;len;
         continue;
      }
      if (d-&gt;ptr[i] == v)
         return LONG2NUM(i);
   }
   return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-round" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            round   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with each entry x replaced by round(x).
(Numbers midway between integers round away from zero.)</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.round   -&gt; Dvector[ 1, -2, 5 ]</pre>
          
          

          
          <div class="method-source-code" id="round-source">
            <pre>VALUE dvector_round(VALUE ary) {
   return dvector_apply_math_op(ary, do_round);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-round-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            round!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with the integer closest to x.
(Numbers midway between integers round away from zero.)</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.round!   -&gt; Dvector[ 1, -2, 5 ]
a          -&gt; Dvector[ 1, -2, 5 ]</pre>
          
          

          
          <div class="method-source-code" id="round-21-source">
            <pre>VALUE dvector_round_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, do_round);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-safe_acos" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            safe_acos   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a copy of <em>dvector</em> with each entry x replaced by
acos(max(-1,min(1,x))).</p>
          
          

          
          <div class="method-source-code" id="safe_acos-source">
            <pre>VALUE dvector_safe_acos(VALUE ary) {
   return dvector_apply_math_op(ary, do_safe_acos);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-safe_acos-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            safe_acos!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replaces each entry x in <em>dvector</em> by acos(max(-1,min(1,x))).</p>
          
          

          
          <div class="method-source-code" id="safe_acos-21-source">
            <pre>VALUE dvector_safe_acos_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, do_safe_acos);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-safe_asin" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            safe_asin   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a copy of <em>dvector</em> with each entry x replaced by
asin(max(-1,min(1,x))).</p>
          
          

          
          <div class="method-source-code" id="safe_asin-source">
            <pre>VALUE dvector_safe_asin(VALUE ary) {
   return dvector_apply_math_op(ary, do_safe_asin);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-safe_asin-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            safe_asin!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replaces each entry x in <em>dvector</em> by asin(max(-1,min(1,x))).</p>
          
          

          
          <div class="method-source-code" id="safe_asin-21-source">
            <pre>VALUE dvector_safe_asin_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, do_safe_asin);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-safe_inv" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            safe_inv(cutoff)   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a copy of <em>dvector</em> with each entry x replaced by
sign(x)/<em>cutoff</em> if abs(x) &lt; <em>cutoff</em>, 1/x otherwise.</p>
          
          

          
          <div class="method-source-code" id="safe_inv-source">
            <pre>VALUE dvector_safe_inv(VALUE ary, VALUE arg) {
   return dvector_apply_math_op1(ary, arg, do_safe_inv);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-safe_inv-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            safe_inv!(cutoff=1e-99)   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replaces each entry x in <em>dvector</em> by sign(x)/<em>cutoff</em> if
abs(x) &lt; <em>cutoff</em>, 1/x otherwise.</p>
          
          

          
          <div class="method-source-code" id="safe_inv-21-source">
            <pre>VALUE dvector_safe_inv_bang(int argc, VALUE *argv, VALUE self) {
   VALUE arg1;
   if ((argc &lt; 0) || (argc &gt; 1))
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0 or 1)&quot;,argc);
   arg1 = (argc &gt; 0)? argv[0] : rb_float_new(1e-99);
   return dvector_apply_math_op1_bang(self, arg1, do_safe_inv);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-safe_log" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            safe_log(cutoff=1e-99)   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a copy of <em>dvector</em> with each entry x replaced by
log(max(x,<em>cutoff</em>)).</p>
          
          

          
          <div class="method-source-code" id="safe_log-source">
            <pre>VALUE dvector_safe_log(int argc, VALUE *argv, VALUE self) {
   VALUE arg1;
   if ((argc &lt; 0) || (argc &gt; 1))
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0 or 1)&quot;,argc);
   arg1 = (argc &gt; 0)? argv[0] : rb_float_new(1e-99);
   return dvector_apply_math_op1(self, arg1, do_safe_log);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-safe_log-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            safe_log!(cutoff=1e-99)   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replaces each entry x in <em>dvector</em> by log(max(x,<em>cutoff</em>)).</p>
          
          

          
          <div class="method-source-code" id="safe_log-21-source">
            <pre>VALUE dvector_safe_log_bang(int argc, VALUE *argv, VALUE self) {
   VALUE arg1;
   if ((argc &lt; 0) || (argc &gt; 1))
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0 or 1)&quot;,argc);
   arg1 = (argc &gt; 0)? argv[0] : rb_float_new(1e-99);
   return dvector_apply_math_op1_bang(self, arg1, do_safe_log);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-safe_log10" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            safe_log10(cutoff=1e-99)   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a copy of <em>dvector</em> with each entry x replaced by
log10(max(x,<em>cutoff</em>)).</p>
          
          

          
          <div class="method-source-code" id="safe_log10-source">
            <pre>VALUE dvector_safe_log10(int argc, VALUE *argv, VALUE self) {
   VALUE arg1;
   if ((argc &lt; 0) || (argc &gt; 1))
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0 or 1)&quot;,argc);
   arg1 = (argc &gt; 0)? argv[0] : rb_float_new(1e-99);
   return dvector_apply_math_op1(self, arg1, do_safe_log10);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-safe_log10-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            safe_log10!(cutoff=1e-99)   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replaces each entry x in <em>dvector</em> by log10(max(x,<em>cutoff</em>)).</p>
          
          

          
          <div class="method-source-code" id="safe_log10-21-source">
            <pre>VALUE dvector_safe_log10_bang(int argc, VALUE *argv, VALUE self) {
   VALUE arg1;
   if ((argc &lt; 0) || (argc &gt; 1))
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0 or 1)&quot;,argc);
   arg1 = (argc &gt; 0)? argv[0] : rb_float_new(1e-99);
   return dvector_apply_math_op1_bang(self, arg1, do_safe_log10);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-safe_sqrt" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            safe_sqrt   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a copy of <em>dvector</em> with each entry x replaced by
sqrt(max(x,0)).</p>
          
          

          
          <div class="method-source-code" id="safe_sqrt-source">
            <pre>VALUE dvector_safe_sqrt(VALUE ary) {
   return dvector_apply_math_op(ary, do_safe_sqrt);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-safe_sqrt-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            safe_sqrt!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replaces each entry x in <em>dvector</em> by sqrt(max(x,0)).</p>
          
          

          
          <div class="method-source-code" id="safe_sqrt-21-source">
            <pre>VALUE dvector_safe_sqrt_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, do_safe_sqrt);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-select" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            select {|x| block } &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Invokes the block passing in successive elements from <em>dvector</em>,
returning a vector containing those elements for which the block returns a
true value (equivalent to <code>Enumerable#select</code>).</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">modulo</span>(<span class="ruby-value">2</span>) <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[<span class="ruby-value">2</span>, <span class="ruby-value">4</span>, <span class="ruby-value">6</span>]
</pre>
          
          

          
          <div class="method-source-code" id="select-source">
            <pre>VALUE dvector_select(VALUE ary) {
   VALUE result, el;
   long i;
   Dvector *d;
   d = Get_Dvector(ary);
   result = dvector_new2(0,d-&gt;len);
   for (i = 0; i &lt; d-&gt;len; i++) {
      el = rb_float_new(d-&gt;ptr[i]);
      if (RTEST(rb_yield(el))) {
         dvector_push(result, el);
      }
   }
   return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-set" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            set(float)  &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            set(a_dvector)  &rarr; dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Modifies the entries of <em>dvector</em> array.  If the argument is a
float, then all of the entries are set to that value.  If the argument is
another <a href="Dvector.html">Dvector</a>, then it must be the same length
as <em>dvector</em>, and its contents are copied to <em>dvector</em>.</p>
          
          

          
          <div class="method-source-code" id="set-source">
            <pre>VALUE dvector_set(VALUE ary, VALUE val) {
   Dvector *d = dvector_modify(ary);
   int len = d-&gt;len, i;
   double *data = d-&gt;ptr;
   if (is_a_dvector(val)) {
      Dvector *d2 = Get_Dvector(val);
      double *data2 = d2-&gt;ptr;
      if (d2-&gt;len != len)
         rb_raise(rb_eArgError, &quot;Vectors must be same length for Dvector set&quot;);
      for (i = 0; i &lt; len; i++) {
         data[i] = data2[i];
      }
   } else {
      double v = NUM2DBL(val);
      for (i = 0; i &lt; len; i++) {
         data[i] = v;
      }
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-shift" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            shift   &rarr;   number or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the first element of <em>dvector</em> and removes it (shifting all
other elements down by one). Returns <code>nil</code> if the vector is
empty.</p>

<pre>args = Dvector[ 1, 2, 3 ]
args.shift   -&gt; 1
args         -&gt; Dvector[ 2, 3 ]</pre>
          
          

          
          <div class="method-source-code" id="shift-source">
            <pre>VALUE dvector_shift(VALUE ary) {
   double top;
   Dvector *d = dvector_modify(ary);
   if (d-&gt;len == 0) return Qnil;
   top = d-&gt;ptr[0];
   dvector_make_shared(ary);
   d-&gt;ptr++;            /* shift ptr */
   d-&gt;len--;
   return rb_float_new(top);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sin" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sin   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with entry x replaced by sin(x).</p>

<pre>a = Dvector[ 1, -2, -3, 4 ]
a.sin   -&gt; Dvector[ sin(1), sin(-2), sin(-3), sin(4) ]</pre>
          
          

          
          <div class="method-source-code" id="sin-source">
            <pre>VALUE dvector_sin(VALUE ary) {
   return dvector_apply_math_op(ary, sin);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sin-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sin!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with sin(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.sin!   -&gt; Dvector[ sin(1.1), sin(-2.2), sin(5.3) ]
a        -&gt; Dvector[ sin(1.1), sin(-2.2), sin(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="sin-21-source">
            <pre>VALUE dvector_sin_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, sin);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sinh" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sinh   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with entry x replaced by sinh(x).</p>

<pre>a = Dvector[ 0.1, -0.2, 0.3 ]
a.sinh   -&gt; Dvector[ sinh(0.1), sinh(-0.2), sinh(0.3) ]</pre>
          
          

          
          <div class="method-source-code" id="sinh-source">
            <pre>VALUE dvector_sinh(VALUE ary) {
   return dvector_apply_math_op(ary, sinh);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sinh-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sinh!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with sinh(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.sinh!   -&gt; Dvector[ sinh(1.1), sinh(-2.2), sinh(5.3) ]
a         -&gt; Dvector[ sinh(1.1), sinh(-2.2), sinh(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="sinh-21-source">
            <pre>VALUE dvector_sinh_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, sinh);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-size" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">size</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-length">length</a>
        </div>
        
      </div>

    
      <div id="method-i-slice" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">slice</span><span
            class="method-args">(p1, p2 = v2)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-5B-5D">[]</a>
        </div>
        
      </div>

    
      <div id="method-i-slice-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            slice!(int)         &rarr; number or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            slice!(start, length) &rarr; sub_vector or nil
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            slice!(range)         &rarr; sub_vector or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Deletes the element(s) given by an index (optionally with a length) or by a
range. Returns the deleted object, subvector, or <code>nil</code> if the
index is out of range.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">5</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-value">3</span> }
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">1</span>)               <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-value">3</span>
<span class="ruby-identifier">a</span>                         <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[<span class="ruby-value">0</span>, <span class="ruby-value">6</span>, <span class="ruby-value">9</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">-1</span>)              <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-value">12</span>
<span class="ruby-identifier">a</span>                         <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[<span class="ruby-value">0</span>, <span class="ruby-value">6</span>, <span class="ruby-value">9</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">100</span>)             <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>
<span class="ruby-identifier">a</span>                         <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[<span class="ruby-value">0</span>, <span class="ruby-value">6</span>, <span class="ruby-value">9</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>)            <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[<span class="ruby-value">6</span>, <span class="ruby-value">9</span>]
<span class="ruby-identifier">a</span>                         <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[<span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>)            <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[]
<span class="ruby-identifier">a</span>                         <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[<span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>)            <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[<span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>                         <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[]
</pre>
          
          

          
          <div class="method-source-code" id="slice-21-source">
            <pre>VALUE dvector_slice_bang(int argc, VALUE *argv, VALUE ary) {
   VALUE arg1, arg2;
   long pos, len;
   Dvector *d;
   d = dvector_modify(ary);
   if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;arg1, &amp;arg2) == 2) {
      pos = NUM2LONG(arg1);
      len = NUM2LONG(arg2);
    delete_pos_len:
      if (pos &lt; 0) {
         pos = d-&gt;len + pos;
      }
      arg2 = dvector_subseq(ary, pos, len);
      dvector_splice(ary, pos, len, Qnil);
      return arg2;
   }
   if (!FIXNUM_P(arg1) &amp;&amp; rb_range_beg_len(arg1, &amp;pos, &amp;len, d-&gt;len, 1)) {
      goto delete_pos_len;
   }
   return dvector_delete_at(ary, NUM2LONG(arg1));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sort" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sort                   &rarr; a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            sort {| a,b | block }  &rarr; a_dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new vector created by sorting <em>dvector</em>. Comparisons for
the sort will be done using the <code>&lt;=&gt;</code> operator or using an
optional code block. The block implements a comparison between <em>a</em>
and <em>b</em>, returning -1, 0, or +1.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">4</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">5</span>, <span class="ruby-value">3</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span>                    <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>                         <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">4</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">5</span>, <span class="ruby-value">3</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-identifier">y</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">x</span> }   <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">5</span>, <span class="ruby-value">4</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span> ]
</pre>
          
          

          
          <div class="method-source-code" id="sort-source">
            <pre>VALUE dvector_sort(VALUE ary) {
    ary = dvector_dup(ary);
    dvector_sort_bang(ary);
    return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sort-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sort!                   &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            sort! {| a,b | block }  &rarr; dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sorts <em>dvector</em> in place. <em>dvev</em> is effectively frozen while
a sort is in progress. Comparisons for the sort will be done using the
<code>&lt;=&gt;</code> operator or using an optional code block. The block
implements a comparison between <em>a</em> and <em>b</em>, returning -1, 0,
or +1.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">4</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">5</span>, <span class="ruby-value">3</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort!</span>                    <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>                          <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-identifier">y</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">x</span> }   <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">5</span>, <span class="ruby-value">4</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span> ]
<span class="ruby-identifier">a</span>                          <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Dvector</span>[ <span class="ruby-value">5</span>, <span class="ruby-value">4</span>, <span class="ruby-value">3</span>, <span class="ruby-value">2</span>, <span class="ruby-value">1</span> ]
</pre>
          
          

          
          <div class="method-source-code" id="sort-21-source">
            <pre>VALUE dvector_sort_bang(VALUE ary) {
   Dvector *d = dvector_modify(ary); /* force &quot;unshared&quot; before start the sort */
   if (d-&gt;len &gt; 1) {
      FL_SET(ary, DVEC_TMPLOCK);        /* prohibit modification during sort */
      rb_ensure(dvector_sort_internal, ary, dvector_sort_unlock, ary);
   }
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sqrt" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sqrt   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with each entry x replaced by sqrt(x).</p>

<pre>a = Dvector[ 1.1, 2.2, 5.3 ]
a.sqrt   -&gt; Dvector[ sqrt(1.1), sqrt(2.2), sqrt(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="sqrt-source">
            <pre>VALUE dvector_sqrt(VALUE ary) {
   return dvector_apply_math_op(ary, sqrt);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sqrt-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sqrt!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with sqrt(x).</p>

<pre>a = Dvector[ 1.1, 2.2, 5.3 ]
a.sqrt!   -&gt; Dvector[ sqrt(1.1), sqrt(2.2), sqrt(5.3) ]
a         -&gt; Dvector[ sqrt(1.1), sqrt(2.2), sqrt(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="sqrt-21-source">
            <pre>VALUE dvector_sqrt_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, sqrt);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sub" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sub(number)       &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            sub(other)        &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector - number          &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            number - dvector          &rarr;  a_dvector
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dvector - other           &rarr;  a_dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, this operation returns a copy of
<em>dvector</em> with each entry x replaced by x - <em>number</em>. When
argument is a vector, this operation returns a copy of <em>dvector</em>
with each entry x replaced by x - the corresponding entry in the
<em>other</em> vector.</p>

<pre>a = Dvector[ 11, -5, 2 ]
a.sub(3)               -&gt; Dvector[ 8, -8, -1 ]
a - 3                  -&gt; Dvector[ 8, -8, -1 ]
3 - a                  -&gt; Dvector[ -8, 8, 1 ]
b = Dvector[ 7, 4, -10 ]
a.sub(b)               -&gt; Dvector[ 4, -9, 12 ]
a - b                  -&gt; Dvector[ 4, -9, 12 ]</pre>
          
          

          
          <div class="method-source-code" id="sub-source">
            <pre>VALUE dvector_sub(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2(ary, arg, do_sub);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-2D">-</a>, <a href="Dvector.html#method-i-minus">minus</a>
        </div>
        

        
      </div>

    
      <div id="method-i-sub-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sub!(number)       &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            sub!(other)        &rarr;  dvector
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When argument is a number, each entry x in <em>dvector</em> is replaced by
x - <em>number</em>. When argument is a vector, each entry x in
<em>dvector</em> is replaced by x -  the corresponding entry in the
<em>other</em> vector.</p>

<pre>a = Dvector[ 11, -5, 2 ]
a.sub!(3)               -&gt; Dvector[ 8, -8, -1 ]
a                       -&gt; Dvector[ 8, -8, -1 ]
b = Dvector[ 7, 4, -10 ]
a = Dvector[ 11, -5, 2 ]
a.sub!(b)               -&gt; Dvector[ 4, -9, 12 ]
a                       -&gt; Dvector[ 4, -9, 12 ]</pre>
          
          

          
          <div class="method-source-code" id="sub-21-source">
            <pre>VALUE dvector_sub_bang(VALUE ary, VALUE arg) {
   return dvector_apply_math_op2_bang(ary, arg, do_sub);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-minus-21">minus!</a>
        </div>
        

        
      </div>

    
      <div id="method-i-sum" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sum   &rarr;  number
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the sum of the entries in <em>dvector</em>. Returns 0.0 if
<em>dvector</em> is empty.</p>

<pre>a = Dvector[ 1, 2, 3, 4 ]
a.sum        -&gt; 10
Dvector[].sum   -&gt; 0</pre>
          
          

          
          <div class="method-source-code" id="sum-source">
            <pre>VALUE dvector_sum(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   double *p = d-&gt;ptr, sum = 0.0;
   long len = d-&gt;len, i;
   for (i=0; i&lt;len; i++) sum += p[i];
   return rb_float_new(sum);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-tan" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            tan   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with entry x replaced by tan(x).</p>

<pre>a = Dvector[ 1, -2, -3, 4 ]
a.tan   -&gt; Dvector[ tan(1), tan(-2), tan(-3), tan(4) ]</pre>
          
          

          
          <div class="method-source-code" id="tan-source">
            <pre>VALUE dvector_tan(VALUE ary) {
   return dvector_apply_math_op(ary, tan);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-tan-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            tan!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with tan(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.tan!   -&gt; Dvector[ tan(1.1), tan(-2.2), tan(5.3) ]
a        -&gt; Dvector[ tan(1.1), tan(-2.2), tan(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="tan-21-source">
            <pre>VALUE dvector_tan_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, tan);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-tanh" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            tanh   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns of copy of <em>dvector</em> with entry x replaced by tanh(x).</p>

<pre>a = Dvector[ 0.1, -0.2, 0.3 ]
a.tanh   -&gt; Dvector[ tanh(0.1), tanh(-0.2), tanh(0.3) ]</pre>
          
          

          
          <div class="method-source-code" id="tanh-source">
            <pre>VALUE dvector_tanh(VALUE ary) {
   return dvector_apply_math_op(ary, tanh);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-tanh-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            tanh!   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Replace each entry x of <em>dvector</em> with tanh(x).</p>

<pre>a = Dvector[ 1.1, -2.2, 5.3 ]
a.tanh!   -&gt; Dvector[ tanh(1.1), tanh(-2.2), tanh(5.3) ]
a         -&gt; Dvector[ tanh(1.1), tanh(-2.2), tanh(5.3) ]</pre>
          
          

          
          <div class="method-source-code" id="tanh-21-source">
            <pre>VALUE dvector_tanh_bang(VALUE ary) {
   return dvector_apply_math_op_bang(ary, tanh);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-times" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">times</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-mul">mul</a>
        </div>
        
      </div>

    
      <div id="method-i-times-21" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">times!</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-mul-21">mul!</a>
        </div>
        
      </div>

    
      <div id="method-i-to_a" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_a     &rarr; an_array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an Array with the same contents as <em>dvector</em>.</p>
          
          

          
          <div class="method-source-code" id="to_a-source">
            <pre>VALUE dvector_to_a(VALUE dvector) {
   Dvector *d = Get_Dvector(dvector);
   long len = d-&gt;len, i;
   double *ptr = d-&gt;ptr;
   VALUE ary = rb_ary_new2(len);
   for (i = 0; i &lt; len; i++) {
      rb_ary_store(ary, i, rb_float_new(*ptr++));
   }
   return ary;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-to_ary">to_ary</a>
        </div>
        

        
      </div>

    
      <div id="method-i-to_ary" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">to_ary</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-to_a">to_a</a>
        </div>
        
      </div>

    
      <div id="method-i-to_dvector" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">to_dvector</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="to_dvector-source">
            <pre><span class="ruby-comment"># File lib/Dobjects/Dvector_extras.rb, line 74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_dvector</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_na" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">to_na</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Create an NArray with the same length and contents as <code>self</code>.</p>
          
          

          
          <div class="method-source-code" id="to_na-source">
            <pre><span class="ruby-comment"># File lib/Dobjects/Dvector_extras.rb, line 69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_na</span>
  <span class="ruby-operator">::</span><span class="ruby-constant">NArray</span>.<span class="ruby-identifier">to_na</span>(<span class="ruby-identifier">_dump</span>(<span class="ruby-keyword">nil</span>)[<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>], <span class="ruby-operator">::</span><span class="ruby-constant">NArray</span><span class="ruby-operator">::</span><span class="ruby-constant">DFLOAT</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_s" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_s &rarr; a_string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <em>dvector</em><code>.join</code>.</p>

<pre>Dvector[ 1, 2, 3 ].to_s        -&gt; &quot;1 2 3&quot;</pre>
          
          

          
          <div class="method-source-code" id="to_s-source">
            <pre>VALUE dvector_to_s(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   if (d-&gt;len == 0) return rb_str_new(0, 0);
   return dvector_join(ary, dvector_output_fs);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-inspect">inspect</a>
        </div>
        

        
      </div>

    
      <div id="method-i-tridag" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            tridag(a,b,c,r) &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sets contents of <em>dvector</em> to solution vector <em>u</em> of the
following tri-diagonal matrix problem.</p>

<pre>|  b[0]  c[0]    0    ...                         |   |  u[0]  |   |  r[0]  |
|  a[1]  b[1]  c[1]   ...                         |   |  u[1]  |   |  r[1]  |
|                     ...                         | * |  ...   | = |  ...   |
|                     ... a[n-2]  b[n-2]  c[n-2]  |   | u[n-2] |   | r[n-2] |
|                     ...   0     a[n-1]  b[n-1]  |   | u[n-1] |   | r[n-1] |</pre>

<p>This corresponds to solving difference equations of the form</p>

<pre>a[j] * u[j-1] + b[j] * u[j] + c[j] * u[j+1] = r[j], for 0 &lt; j &lt; n,</pre>

<p>with boundary conditions</p>

<pre>u[0]   = (r[0] - c[0] * u[1]) / b[0], and
u[n-1] = (r[n-1] - a[n-1] * u[n-2]) / b[n-1].</pre>

<p>See Numerical Recipes for more details.</p>
          
          

          
          <div class="method-source-code" id="tridag-source">
            <pre>VALUE dvector_tridag(VALUE uVec, VALUE aVec, VALUE bVec, VALUE cVec, VALUE rVec) {
    double *u, *a, *b, *c, *r, *gam, bet;
    long j, n, u_len, a_len, b_len, c_len, r_len;
    u = Dvector_Data_for_Read(uVec, &amp;u_len);
    a = Dvector_Data_for_Read(aVec, &amp;a_len);
    b = Dvector_Data_for_Read(bVec, &amp;b_len);
    c = Dvector_Data_for_Read(cVec, &amp;c_len);
    r = Dvector_Data_for_Read(rVec, &amp;r_len);
    if (a_len != b_len || b_len != c_len || c_len != r_len) {
        rb_raise(rb_eArgError, &quot;vectors with different lengths for tridag&quot;);
    }
    n = a_len;
    if (u_len != a_len) u = Dvector_Data_Resize(uVec, a_len);
    gam = (double *)ALLOC_N(double, n);
    if (b[0] == 0.0) {
        rb_raise(rb_eArgError, &quot;b[0] is zero in tridag&quot;);
    }
    u[0] = r[0] / (bet = b[0]);
    for (j = 1; j &lt; n; j++) {  // decomposition and forward substitution
        gam[j] = c[j-1] / bet;
        bet = b[j] - a[j]*gam[j];
        if (bet == 0.0) {
            rb_raise(rb_eArgError, &quot;zero divisor in tridag (j=%ld)&quot;, j);
        }
        u[j] = (r[j] - a[j]*u[j-1]) / bet;
    }
    for (j = n-2; j &gt;= 0; j--) { // backsubstitution
        u[j] -= gam[j+1]*u[j+1];
    }
    free(gam);
    return uVec;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-trim" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            trim(cutoff=1e-6)   &rarr;  a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a copy of <em>dvector</em> with any entry with absolute value less
than <em>cutoff</em> replaced by 0.</p>

<pre>a = Dvector[ 1.1, 1e-20, -5.3 ]
a.trim  -&gt; Dvector[ 1.1, 0, -5.3 ]</pre>
          
          

          
          <div class="method-source-code" id="trim-source">
            <pre>VALUE dvector_trim(int argc, VALUE *argv, VALUE self) {
   VALUE arg1;
   if ((argc &lt; 0) || (argc &gt; 1))
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0 or 1)&quot;,argc);
   arg1 = (argc &gt; 0)? argv[0] : rb_float_new(1e-6);
   return dvector_apply_math_op1(self, arg1, do_trim);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-trim-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            trim!(cutoff=1e-6)   &rarr;  dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Each entry x in <em>dvector</em> having absolute value less than
<em>cutoff</em> is replaced by 0.</p>

<pre>a = Dvector[ 1.1, 1e-20, -5.3 ]
a.trim!  -&gt; Dvector[ 1.1, 0, -5.3 ]</pre>
          
          

          
          <div class="method-source-code" id="trim-21-source">
            <pre>VALUE dvector_trim_bang(int argc, VALUE *argv, VALUE self) {
   VALUE arg1;
   if ((argc &lt; 0) || (argc &gt; 1))
      rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0 or 1)&quot;,argc);
   arg1 = (argc &gt; 0)? argv[0] : rb_float_new(1e-6);
   return dvector_apply_math_op1_bang(self, arg1, do_trim);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-uniq" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            uniq &rarr; a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new vector by removing duplicate elements from <em>dvector</em>.
Remove the element if there is a later one in the vector that is equal to
it.</p>

<pre>a = Dvector[ 1.1, 3.8, 1.7, 3.8, 5 ]
a.uniq              -&gt;   Dvector[1.1, 1.7, 3.8, 5]</pre>
          
          

          
          <div class="method-source-code" id="uniq-source">
            <pre>VALUE dvector_uniq(VALUE ary) {
   VALUE new = dvector_uniq_bang(dvector_dup(ary));
   if (new == Qnil) new = ary;
   return new;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-uniq-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            uniq! &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Same as <a href="Dvector.html#method-i-uniq">#uniq</a>, but modifies the
receiver in place.  Returns nil if no changes are made (that is, no
duplicates are found).</p>

<pre>Removes duplicate elements from dvector.
Deletes the element if there is a later one in the vector that is equal to it.

   a = Dvector[ 1.1, 3.8, 1.7, 3.8, 5 ]
   a.uniq!              -&gt;   Dvector[1.1, 1.7, 3.8, 5]
   b = Dvector[ 1.1, 3.8, 1.7, 5 ]
   b.uniq!              -&gt;   nil</pre>
          
          

          
          <div class="method-source-code" id="uniq-21-source">
            <pre>VALUE dvector_uniq_bang(VALUE ary) {
   double v;
   Dvector *d = dvector_modify(ary);
   long i, j, k;
   int uniq;
   for (i=j=0; i &lt; d-&gt;len; i++) {
      v = d-&gt;ptr[i];
      uniq = true;
      for (k=i+1; k &lt; d-&gt;len; k++) {
         if (d-&gt;ptr[k] == v) {
            uniq = false;
            break;
         }
      } 
      if (uniq) d-&gt;ptr[j++] = v;
   }
   if (d-&gt;len == j) return Qnil;
   d-&gt;len = j;
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-unshift" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            unshift(number, ...)  &rarr; dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Prepends objects to the front of <em>dvector</em>, moving other elements up
one.</p>

<pre>a = [ 2, 3, 4 ]
a.unshift(1)      -&gt; Dvector[ 1, 2, 3, 4 ]
a.unshift(-1, 0)  -&gt; Dvector[ -1, 0, 1, 2, 3, 4 ]</pre>
          
          

          
          <div class="method-source-code" id="unshift-source">
            <pre>VALUE dvector_unshift_m(int argc, VALUE *argv, VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   long len = d-&gt;len, i;
   if (argc &lt; 0) {
      rb_raise(rb_eArgError, &quot;negative number of arguments&quot;);
   }
   if (argc == 0) return ary;
   /* make room by setting the last item */
   Dvector_Store_Double(ary, len + argc - 1, 0.0);
   /* slide items */
   MEMMOVE(d-&gt;ptr + argc, d-&gt;ptr, double, len);
   for (i=0; i &lt; argc; i++)
      dvector_store(ary, i, argv[i]);
   return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-values_at" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            values_at(selector,... )   &rarr; a_dvector
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new vector containing the elements in <em>dvector</em>
corresponding to the given selector(s). The selectors may be either integer
indices or ranges.</p>

<pre>a = Dvector[ 1, 2, 3, 4, 5, 6 ]
a.values_at(1, 3, 5)           -&gt; Dvector[ 2, 4, 6 ]
a.values_at(1, 3, 5, 7)        -&gt; Dvector[ 2, 4, 6 ]
a.values_at(-1, -3, -5, -7)    -&gt; Dvector[ 6, 4, 2 ]
a.values_at(1..3, 2...5)       -&gt; Dvector[ 2, 3, 4, 3, 4, 5 ]</pre>
          
          

          
          <div class="method-source-code" id="values_at-source">
            <pre>VALUE dvector_values_at(int argc, VALUE *argv, VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   long olen = d-&gt;len;
   VALUE result = dvector_new();
   long beg, len, i, j;
   for (i=0; i&lt;argc; i++) {
      if (FIXNUM_P(argv[i])) {
         j = FIX2LONG(argv[i]);
         if (j &lt; 0) j += d-&gt;len;
         if (j &gt;= 0 &amp;&amp; j &lt; d-&gt;len) Dvector_Push_Double(result, d-&gt;ptr[j]);
         continue;
      }
      /* check if idx is Range */
      switch (rb_range_beg_len(argv[i], &amp;beg, &amp;len, olen, 0)) {
         case Qfalse:
            break;
         case Qnil:
            continue;
         default:
         for (j=0; j&lt;len; j++) {
            if (j+beg &gt;= 0 &amp;&amp; j+beg &lt; d-&gt;len) Dvector_Push_Double(result, d-&gt;ptr[j+beg]);
         }
         continue;
      }
      j = NUM2LONG(argv[i]);
      if (j &lt; 0) j += d-&gt;len;
      if (j &gt;= 0 &amp;&amp; j &lt; d-&gt;len) Dvector_Push_Double(result, d-&gt;ptr[j]);
   }
   return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-vector_length" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            vector_length   &rarr;  number
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns square root of the dot product of the vector with itself.</p>

<pre>a = Dvector[ 3, 4 ]
a.vector_length -&gt; 5.0</pre>
          
          

          
          <div class="method-source-code" id="vector_length-source">
            <pre>VALUE dvector_vector_length(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   double *p = d-&gt;ptr, sum = 0.0;
   long len = d-&gt;len, i;
   for (i=0; i&lt;len; i++) sum += p[i] * p[i];
   return rb_float_new(sqrt(sum));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-where_closest" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_closest(number)         &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            where_first_closest(number)   &rarr;  int or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the first entry in <em>dvector</em> with value closest
to <em>number</em>, <code>nil</code> if <em>dvector</em> is empty.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_closest(3.9)        -&gt; 3
Dvector[].where_closest(3.9)   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_closest-source">
            <pre>VALUE dvector_where_closest(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   item = rb_Float(item);
   double x = NUM2DBL(item), *p = d-&gt;ptr, tmp, bst;
   long len = d-&gt;len, i, bst_i;
   if (len &lt;= 0) return Qnil;
   bst = fabs(p[0]-x);
   if (bst == 0.0) return INT2FIX(0);
   bst_i = 0;
   for (i=1; i&lt;len; i++) {
      tmp = p[i] - x;
      if (tmp == 0.0) return INT2FIX(i);
      if (tmp &lt; 0.0) tmp = -tmp;
      if (tmp &lt; bst) { bst_i = i; bst = tmp; }
   }
   return INT2FIX(bst_i);   
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-where_first_closest">where_first_closest</a>
        </div>
        

        
      </div>

    
      <div id="method-i-where_eq" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">where_eq</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-where_first_eq">where_first_eq</a>
        </div>
        
      </div>

    
      <div id="method-i-where_first_closest" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">where_first_closest</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-where_closest">where_closest</a>
        </div>
        
      </div>

    
      <div id="method-i-where_first_eq" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_eq(number)         &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            where_first_eq(number)   &rarr;  int or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the first entry in <em>dvector</em> with value equal
to <em>number</em>, <code>nil</code> if <em>dvector</em> has no such entry.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_eq(4)        -&gt; 3
a.where_eq(6)        -&gt; nil
Dvector[].where_eq(4)   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_first_eq-source">
            <pre>VALUE dvector_where_first_eq(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   item = rb_Float(item);
   double x = NUM2DBL(item), *p = d-&gt;ptr;
   long len = d-&gt;len, i;
   if (len &lt;= 0) return Qnil;
   for (i=0; i&lt;len; i++) {
      if (p[i] == x) return INT2FIX(i);
   }
   return Qnil;   
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-where_eq">where_eq</a>
        </div>
        

        
      </div>

    
      <div id="method-i-where_first_ge" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_ge(number)         &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            where_first_ge(number)   &rarr;  int or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the first entry in <em>dvector</em> with value greater
than or equal <em>number</em>, <code>nil</code> if <em>dvector</em> has no
such entry.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_ge(3)        -&gt; 3
a.where_ge(5)        -&gt; nil
Dvector[].where_ge(0)   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_first_ge-source">
            <pre>VALUE dvector_where_first_ge(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   item = rb_Float(item);
   double x = NUM2DBL(item), *p = d-&gt;ptr;
   long len = d-&gt;len, i;
   if (len &lt;= 0) return Qnil;
   for (i=0; i&lt;len; i++) {
      if (p[i] &gt;= x) return INT2FIX(i);
   }
   return Qnil;   
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-where_ge">where_ge</a>
        </div>
        

        
      </div>

    
      <div id="method-i-where_first_gt" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_gt(number)         &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            where_first_gt(number)   &rarr;  int or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the first entry in <em>dvector</em> with value greater
than <em>number</em>, <code>nil</code> if <em>dvector</em> has no such
entry.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_gt(3)        -&gt; 3
a.where_gt(4)        -&gt; nil
Dvector[].where_gt(0)   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_first_gt-source">
            <pre>VALUE dvector_where_first_gt(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   item = rb_Float(item);
   double x = NUM2DBL(item), *p = d-&gt;ptr;
   long len = d-&gt;len, i;
   if (len &lt;= 0) return Qnil;
   for (i=0; i&lt;len; i++) {
      if (p[i] &gt; x) return INT2FIX(i);
   }
   return Qnil;   
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-where_gt">where_gt</a>
        </div>
        

        
      </div>

    
      <div id="method-i-where_first_le" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_le(number)         &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            where_first_le(number)   &rarr;  int or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the first entry in <em>dvector</em> with value less
than or equal <em>number</em>, <code>nil</code> if <em>dvector</em> has no
such entry.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_le(0)        -&gt; 2
a.where_le(-5.5)     -&gt; nil
Dvector[].where_le(4)   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_first_le-source">
            <pre>VALUE dvector_where_first_le(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   item = rb_Float(item);
   double x = NUM2DBL(item), *p = d-&gt;ptr;
   long len = d-&gt;len, i;
   if (len &lt;= 0) return Qnil;
   for (i=0; i&lt;len; i++) {
      if (p[i] &lt;= x) return INT2FIX(i);
   }
   return Qnil;   
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-where_le">where_le</a>
        </div>
        

        
      </div>

    
      <div id="method-i-where_first_lt" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_lt(number)          &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            where_first_lt(number)    &rarr;  int or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the first entry in <em>dvector</em> with value less
than <em>number</em>, <code>nil</code> if <em>dvector</em> has no such
entry.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_lt(1)        -&gt; 2
a.where_lt(-5)       -&gt; nil
Dvector[].where_lt(4)   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_first_lt-source">
            <pre>VALUE dvector_where_first_lt(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   item = rb_Float(item);
   double x = NUM2DBL(item), *p = d-&gt;ptr;
   long len = d-&gt;len, i;
   if (len &lt;= 0) return Qnil;
   for (i=0; i&lt;len; i++) {
      if (p[i] &lt; x) return INT2FIX(i);
   }
   return Qnil;   
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-where_lt">where_lt</a>
        </div>
        

        
      </div>

    
      <div id="method-i-where_first_max" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">where_first_max</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-where_max">where_max</a>
        </div>
        
      </div>

    
      <div id="method-i-where_first_min" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">where_first_min</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-where_min">where_min</a>
        </div>
        
      </div>

    
      <div id="method-i-where_first_ne" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_ne(number)         &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            where_first_ne(number)   &rarr;  int or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the first entry in <em>dvector</em> with value not
equal to <em>number</em>, <code>nil</code> if <em>dvector</em> has no such
entry.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_ne(1)        -&gt; 1
Dvector[].where_ne(4)   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_first_ne-source">
            <pre>VALUE dvector_where_first_ne(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   item = rb_Float(item);
   double x = NUM2DBL(item), *p = d-&gt;ptr;
   long len = d-&gt;len, i;
   if (len &lt;= 0) return Qnil;
   for (i=0; i&lt;len; i++) {
      if (p[i] != x) return INT2FIX(i);
   }
   return Qnil;   
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-where_ne">where_ne</a>
        </div>
        

        
      </div>

    
      <div id="method-i-where_ge" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">where_ge</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-where_first_ge">where_first_ge</a>
        </div>
        
      </div>

    
      <div id="method-i-where_gt" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">where_gt</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-where_first_gt">where_first_gt</a>
        </div>
        
      </div>

    
      <div id="method-i-where_last_closest" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_last_closest(number)   &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the last entry in <em>dvector</em> with value closest
to <em>number</em>, <code>nil</code> if <em>dvector</em> is empty.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_last_closest(3.9)         -&gt; 5
Dvector[].where_last_closest(3.9)    -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_last_closest-source">
            <pre>VALUE dvector_where_last_closest(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   item = rb_Float(item);
   double x = NUM2DBL(item), *p = d-&gt;ptr, tmp, bst;
   long len = d-&gt;len, i, bst_i;
   if (len &lt;= 0) return Qnil;
   bst_i = len-1;
   bst = fabs(p[bst_i]-x);
   if (bst == 0.0) return INT2FIX(bst_i);
   for (i=bst_i-1; i&gt;=0; i--) {
      tmp = p[i] - x;
      if (tmp == 0.0) return INT2FIX(i);
      if (tmp &lt; 0.0) tmp = -tmp;
      if (tmp &lt; bst) { bst_i = i; bst = tmp; }
   }
   return INT2FIX(bst_i);   
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-where_last_eq" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_last_eq(number)   &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the last entry in <em>dvector</em> with value equal
<em>number</em>, <code>nil</code> if <em>dvector</em> has no such entry.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_last_eq(2)         -&gt; 8
a.where_last_eq(5)         -&gt; nil
Dvector[].where_last_eq(0)    -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_last_eq-source">
            <pre>VALUE dvector_where_last_eq(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   item = rb_Float(item);
   double x = NUM2DBL(item), *p = d-&gt;ptr;
   long len = d-&gt;len, i;
   if (len &lt;= 0) return Qnil;
   for (i=len-1; i&gt;=0; i--) {
      if (p[i] == x) return INT2FIX(i);
   }
   return Qnil;   
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-where_last_ge" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_last_ge(number)   &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the last entry in <em>dvector</em> with value greater
than or equal <em>number</em>, <code>nil</code> if <em>dvector</em> has no
such entry.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_last_ge(4)        -&gt; 5
a.where_last_ge(5)        -&gt; nil
Dvector[].where_last_ge(0)   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_last_ge-source">
            <pre>VALUE dvector_where_last_ge(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   item = rb_Float(item);
   double x = NUM2DBL(item), *p = d-&gt;ptr;
   long len = d-&gt;len, i;
   if (len &lt;= 0) return Qnil;
   for (i=len-1; i&gt;=0; i--) {
      if (p[i] &gt;= x) return INT2FIX(i);
   }
   return Qnil;   
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-where_last_gt" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_last_gt(number)   &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the last entry in <em>dvector</em> with value greater
than <em>number</em>, <code>nil</code> if <em>dvector</em> has no such
entry.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_last_gt(2)        -&gt; 6
a.where_last_gt(4)        -&gt; nil
Dvector[].where_last_gt(0)   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_last_gt-source">
            <pre>VALUE dvector_where_last_gt(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   item = rb_Float(item);
   double x = NUM2DBL(item), *p = d-&gt;ptr;
   long len = d-&gt;len, i;
   if (len &lt;= 0) return Qnil;
   for (i=len-1; i&gt;=0; i--) {
      if (p[i] &gt; x) return INT2FIX(i);
   }
   return Qnil;   
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-where_last_le" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_last_le(number)   &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the last entry in <em>dvector</em> with value less
than or equal <em>number</em>, <code>nil</code> if <em>dvector</em> has no
such entry.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_last_le(1)        -&gt; 7
a.where_last_le(-6)       -&gt; nil
Dvector[].where_last_le(0)   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_last_le-source">
            <pre>VALUE dvector_where_last_le(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   item = rb_Float(item);
   double x = NUM2DBL(item), *p = d-&gt;ptr;
   long len = d-&gt;len, i;
   if (len &lt;= 0) return Qnil;
   for (i=len-1; i&gt;=0; i--) {
      if (p[i] &lt;= x) return INT2FIX(i);
   }
   return Qnil;   
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-where_last_lt" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_last_lt(number)   &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the last entry in <em>dvector</em> with value less
than <em>number</em>, <code>nil</code> if <em>dvector</em> has no such
entry.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_last_lt(2)        -&gt; 7
a.where_last_lt(-5)       -&gt; nil
Dvector[].where_last_lt(0)   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_last_lt-source">
            <pre>VALUE dvector_where_last_lt(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   item = rb_Float(item);
   double x = NUM2DBL(item), *p = d-&gt;ptr;
   long len = d-&gt;len, i;
   if (len &lt;= 0) return Qnil;
   for (i=len-1; i&gt;=0; i--) {
      if (p[i] &lt; x) return INT2FIX(i);
   }
   return Qnil;   
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-where_last_max" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_last_max   &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the last entry with the maximum value in
<em>dvector</em>. Returns <code>nil</code> if <em>dvector</em> is empty.</p>

<pre>a = Dvector[ 1, 2, 3, 4, 5, 4, 3, 5, 2 ]
a.where_last_max        -&gt; 7
Dvector[].where_last_max   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_last_max-source">
            <pre>VALUE dvector_where_last_max(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   double *p = d-&gt;ptr, bst;
   long len = d-&gt;len, i, bst_i;
   if (len &lt;= 0) return Qnil;
   bst_i = len-1;
   bst = p[bst_i];
   for (i=bst_i-1; i&gt;=0; i--) {
      if (p[i] &gt; bst) { bst_i = i; bst = p[i]; }
   }
   return INT2FIX(bst_i);   
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-where_last_min" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_last_min   &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the last entry with the minimum value in
<em>dvector</em>, <code>nil</code> if <em>dvector</em> is empty.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_last_min         -&gt; 7
Dvector[].where_last_min    -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_last_min-source">
            <pre>VALUE dvector_where_last_min(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   double *p = d-&gt;ptr, bst;
   long len = d-&gt;len, i, bst_i;
   if (len &lt;= 0) return Qnil;
   bst_i = len-1;
   bst = p[bst_i];
   for (i=bst_i-1; i&gt;=0; i--) {
      if (p[i] &lt; bst) { bst_i = i; bst = p[i]; }
   }
   return INT2FIX(bst_i);   
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-where_last_ne" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_last_ne(number)   &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the last entry in <em>dvector</em> with value not
equal <em>number</em>, <code>nil</code> if <em>dvector</em> has no such
entry.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_last_ne(2)        -&gt; 7
Dvector[0].where_last_ne(0)  -&gt; nil
Dvector[].where_last_ne(0)   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_last_ne-source">
            <pre>VALUE dvector_where_last_ne(VALUE ary, VALUE item) {
   Dvector *d = Get_Dvector(ary);
   item = rb_Float(item);
   double x = NUM2DBL(item), *p = d-&gt;ptr;
   long len = d-&gt;len, i;
   if (len &lt;= 0) return Qnil;
   for (i=len-1; i&gt;=0; i--) {
      if (p[i] != x) return INT2FIX(i);
   }
   return Qnil;   
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-where_le" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">where_le</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-where_first_le">where_first_le</a>
        </div>
        
      </div>

    
      <div id="method-i-where_lt" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">where_lt</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-where_first_lt">where_first_lt</a>
        </div>
        
      </div>

    
      <div id="method-i-where_max" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_max         &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            where_first_max   &rarr;  int or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the first entry with the maximum value in
<em>dvector</em>. Returns <code>nil</code> if <em>dvector</em> is empty.</p>

<pre>a = Dvector[ 1, 2, 3, 4, 5, 4, 3, 5, 2 ]
a.where_max        -&gt; 4
Dvector[].where_max   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_max-source">
            <pre>VALUE dvector_where_max(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   double *p = d-&gt;ptr, bst;
   long len = d-&gt;len, i, bst_i;
   if (len &lt;= 0) return Qnil;
   bst = p[0];
   bst_i = 0;
   for (i=1; i&lt;len; i++) {
      if (p[i] &gt; bst) { bst_i = i; bst = p[i]; }
   }
   return INT2FIX(bst_i);   
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-where_first_max">where_first_max</a>
        </div>
        

        
      </div>

    
      <div id="method-i-where_min" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            where_min         &rarr;  int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            where_first_min   &rarr;  int or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the index of the first entry with the minimum value in
<em>dvector</em>, <code>nil</code> if <em>dvector</em> is empty.</p>

<pre>a = Dvector[ 1, 2, -3, 4, -5, 4, 3, -5, 2 ]
a.where_min        -&gt; 4
Dvector[].where_min   -&gt; nil</pre>
          
          

          
          <div class="method-source-code" id="where_min-source">
            <pre>VALUE dvector_where_min(VALUE ary) {
   Dvector *d = Get_Dvector(ary);
   double bst, *p = d-&gt;ptr;
   long len = d-&gt;len, i, bst_i;
   if (len &lt;= 0) return Qnil;
   bst = p[0];
   bst_i = 0;
   for (i=1; i&lt;len; i++) {
      if (p[i] &lt; bst) { bst_i = i; bst = p[i]; }
   }
   return INT2FIX(bst_i);   
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Dvector.html#method-i-where_first_min">where_first_min</a>
        </div>
        

        
      </div>

    
      <div id="method-i-where_ne" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">where_ne</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Dvector.html#method-i-where_first_ne">where_first_ne</a>
        </div>
        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

